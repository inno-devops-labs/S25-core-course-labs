# Lab 13: ArgoCD for GitOps Deployment

## Overview

In this lab, we implemented ArgoCD to automate Kubernetes application deployments using GitOps principles. We installed ArgoCD via Helm, configured it to manage applications, and simulated production-like workflows.

## Task 1: Deploy and Configure ArgoCD

### 1. Installation Steps Performed

1. Added the ArgoCD Helm repository:
   ```bash
   helm repo add argo https://argoproj.github.io/argo-helm
   ```

2. Installed ArgoCD:
   ```bash
   helm install argo argo/argo-cd --namespace argocd --create-namespace
   ```

3. Verified installation:
   ```bash
   kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=90s
   ```

### 2. ArgoCD CLI Installation

1. Installed the ArgoCD CLI tool:
   ```bash
   brew install argocd
   ```

2. Verified CLI installation:
   ```bash
   argocd version
   ```

### 3. Accessing ArgoCD UI

1. Port-forwarded the ArgoCD server:
   ```bash
   kubectl port-forward svc/argo-argocd-server -n argocd 8080:443 &
   ```

2. Retrieved and used the initial admin password:
   ```bash
   kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode
   argocd login localhost:8080 --insecure --username admin --password <password>
   ```

### 4. Python App Sync Configuration

1. Created ArgoCD application manifests in `k8s/ArgoCD/` directory
2. Deployed a sample application using ArgoCD
3. Verified the application deployment

## Task 2: Multi-Environment Deployment & Auto-Sync

### 1. Multi-Environment Configurations

1. Created namespaces for different environments:
   ```bash
   kubectl create namespace dev
   kubectl create namespace prod
   ```

2. Created ArgoCD application manifests for dev and prod environments
3. Applied the configurations and synced the applications

### 2. Self-Heal Testing

#### Test 1: Manual Override of Replica Count

1. Modified the deployment's replica count manually:
   ```bash
   kubectl patch deployment guestbook-ui -n prod --patch '{"spec":{"replicas": 3}}'
   ```

2. Observed pods before ArgoCD auto-sync:
   ```
   NAME                            READY   STATUS              RESTARTS   AGE
   guestbook-ui-764d76f89d-7jjbl   1/1     Running             0          37s
   guestbook-ui-764d76f89d-nvjgq   0/1     ContainerCreating   0          5s
   guestbook-ui-764d76f89d-xf7rg   0/1     ContainerCreating   0          5s
   ```

3. Observed ArgoCD detecting the drift:
   ```
   Sync Status:        OutOfSync from HEAD (4773b9f)
   ```

4. ArgoCD auto-reverted the change (due to syncPolicy.automated):
   ```
   argocd app sync python-app-prod
   ```

5. Pods after ArgoCD auto-sync:
   ```
   NAME                            READY   STATUS    RESTARTS   AGE
   guestbook-ui-764d76f89d-7jjbl   1/1     Running   0          57s
   ```

#### Test 2: Delete a Pod (Replica)

1. Deleted a pod in the prod namespace:
   ```bash
   kubectl delete pod -n prod -l app=guestbook-ui
   ```

2. Kubernetes automatically recreated the pod:
   ```
   NAME                            READY   STATUS    RESTARTS   AGE
   guestbook-ui-764d76f89d-n6bcn   1/1     Running   0          67s
   ```

3. ArgoCD showed no drift (since pod deletions don't affect the desired state):
   ```
   argocd app diff python-app-prod
   ```

## Understanding Configuration Drift vs. Runtime Events

### Configuration Drift
ArgoCD detects and corrects configuration drift, such as changes to the number of replicas, resource limits, or other specifications defined in the manifests. When we manually changed the replica count to 3, ArgoCD detected this as drift from the desired state and automatically reverted it back to 1 as defined in the manifest.

### Runtime Events
Runtime events, such as pod deletions or restarts, are handled by Kubernetes itself and not by ArgoCD. When we deleted a pod, Kubernetes' own controllers (like the ReplicaSet controller) recreated the pod to match the desired state. ArgoCD doesn't need to intervene because the desired configuration (1 replica) remained unchanged - it was just the runtime state that temporarily changed.

This distinction shows the complementary roles of Kubernetes and ArgoCD:
- Kubernetes handles runtime state and reconciliation at the cluster level
- ArgoCD handles configuration state and reconciliation against Git as the source of truth

The combination ensures both configuration consistency and runtime resilience. 