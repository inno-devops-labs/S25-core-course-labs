# Lab 14: Kubernetes StatefulSet

## Task 1: Implement StatefulSet in Helm Chart

```bash
demanzverev@MacBook-Pro-Deman k8s % helm install --dry-run --debug my-app ./my-app
install.go:225: 2025-04-29 11:58:48.024897 +0300 MSK m=+0.145615792 [debug] Original chart version: ""
install.go:242: 2025-04-29 11:58:48.025395 +0300 MSK m=+0.146113626 [debug] CHART PATH: /Users/demanzverev/PycharmProjects/S25-core-course-labs/k8s/my-app

NAME: my-app
LAST DEPLOYED: Tue Apr 29 11:58:48 2025
NAMESPACE: default
STATUS: pending-install
REVISION: 1
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
affinity: {}
autoscaling:
  enabled: false
  maxReplicas: 100
  minReplicas: 1
  targetCPUUtilizationPercentage: 80
fullnameOverride: ""
image:
  pullPolicy: IfNotPresent
  repository: demakoder/app_python
  tag: latest
imagePullSecrets: []
ingress:
  annotations: {}
  className: ""
  enabled: false
  hosts:
  - host: chart-example.local
    paths:
    - path: /
      pathType: ImplementationSpecific
  tls: []
livenessProbe:
  httpGet:
    path: /healthz
    port: 5000
nameOverride: ""
nodeSelector: {}
persistence:
  accessModes:
  - ReadWriteOnce
  enabled: true
  mountPath: /data
  size: 1Gi
  storageClass: ""
podAnnotations: {}
podLabels: {}
podSecurityContext: {}
readinessProbe:
  httpGet:
    path: /ready
    port: 5000
replicaCount: 1
resources: {}
secret:
  password: supersecretpassword
securityContext: {}
service:
  clusterIP: None
  port: 5000
  type: ClusterIP
serviceAccount:
  annotations: {}
  automount: true
  create: true
  name: ""
statefulset:
  enabled: true
  podManagementPolicy: OrderedReady
  serviceName: app-python-service
  updateStrategy:
    type: RollingUpdate
tolerations: []
volumeMounts: []
volumes: []

HOOKS:
---
# Source: my-app/templates/post-install-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: postinstall-hook
  annotations:
    "helm.sh/hook": "post-install"
    "helm.sh/hook-delete-policy": "hook-succeeded"
spec:
  containers:
    - name: post-install-container
      image: busybox
      imagePullPolicy: Always
      command: ['sh', '-c', 'echo The post-install hook is running && sleep 15' ]
  restartPolicy: Never
  terminationGracePeriodSeconds: 0
---
# Source: my-app/templates/pre-install-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: preinstall-hook
  annotations:
    "helm.sh/hook": "pre-install"
    "helm.sh/hook-delete-policy": "hook-succeeded"
spec:
  containers:
    - name: pre-install-container
      image: busybox
      imagePullPolicy: IfNotPresent
      command: ['sh', '-c', 'echo The pre-install hook is running && sleep 20' ]
  restartPolicy: Never
  terminationGracePeriodSeconds: 0
---
# Source: my-app/templates/tests/test-connection.yaml
apiVersion: v1
kind: Pod
metadata:
  name: "my-app-test-connection"
  labels:
    helm.sh/chart: my-app-0.1.0
    app.kubernetes.io/name: my-app
    app.kubernetes.io/instance: my-app
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args: ['my-app:5000']
  restartPolicy: Never
MANIFEST:
---
# Source: my-app/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-app
  labels:
    helm.sh/chart: my-app-0.1.0
    app.kubernetes.io/name: my-app
    app.kubernetes.io/instance: my-app
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
automountServiceAccountToken: true
---
# Source: my-app/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-app-secret
  labels:
    helm.sh/chart: my-app-0.1.0
    app.kubernetes.io/name: my-app
    app.kubernetes.io/instance: my-app
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  MY_PASS: "c3VwZXJzZWNyZXRwYXNzd29yZA=="
---
# Source: my-app/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-app-config
data:
  config.json: |-
    {
      "appName": "My Flask App",
      "version": "1.0.0",
      "environment": "production"
    }
---
# Source: my-app/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app
  labels:
    helm.sh/chart: my-app-0.1.0
    app.kubernetes.io/name: my-app
    app.kubernetes.io/instance: my-app
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  ports:
    - port: 5000
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: my-app
    app.kubernetes.io/instance: my-app
---
# Source: my-app/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-app
  labels:
    helm.sh/chart: my-app-0.1.0
    app.kubernetes.io/name: my-app
    app.kubernetes.io/instance: my-app
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
spec:
  serviceName: my-app
  replicas: 1
  podManagementPolicy: Parallel
  selector:
    matchLabels:
      app.kubernetes.io/name: my-app
      app.kubernetes.io/instance: my-app
  template:
    metadata:
      labels:
        app.kubernetes.io/name: my-app
        app.kubernetes.io/instance: my-app
    spec:
      containers:
        - name: my-app
          image: "demakoder/app_python:latest"
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5000
          volumeMounts:
            - name: data
              mountPath: /data
          livenessProbe:
            httpGet:
              path: /
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 8000
            initialDelaySeconds: 2
            periodSeconds: 5
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 1Gi

NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=my-app,app.kubernetes.io/instance=my-app" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT

```

## Task 2: StatefulSet Exploration and Optimization

```bash
$ kubectl get sts,pods,svc,pvc -n default
NAME                        READY   AGE
statefulset.apps/my-app   2/2     85s

NAME                                       READY   STATUS      RESTARTS   AGE
pod/post-install-hook                      0/1     Completed   0          34m
pod/pre-install-hook                       0/1     Completed   0          3m19s
pod/python-app-my-app-7f986454b5-gc469   1/1     Running     0          135m
pod/python-app-my-app-7f986454b5-qcshb   1/1     Running     0          50m
pod/test-app-0                             1/1     Running     0          85s
pod/test-app-1                             1/1     Running     0          82s

NAME                          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/kubernetes            ClusterIP   10.96.0.1        <none>        443/TCP    141m
service/python-app-test-app   ClusterIP   10.101.251.131   <none>        8000/TCP   135m
service/test-app              ClusterIP   10.110.136.219   <none>        8000/TCP   85s

NAME                                    STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/data-my-app-0   Bound    pvc-ad7c6a85-80ec-4cff-97eb-a13d0b7ec7cc   1Gi        RWO            standard       <unset>                 85s
persistentvolumeclaim/data-my-app-1   Bound    pvc-aa3bea1e-0a7b-44bd-bd62-e2a6a63e03cc   1Gi        RWO            standard       <unset>                 82s
```


I accessed my application using:

```bash
$ minikube service my-app
```

Content of visits:
```bash
$ kubectl exec my-app-0 -- cat /data/visits
$ kubectl exec my-app-1 -- cat /data/visits
# output
14
10
```

The PVC after deleting the pod with `kubectl delete pod my-app-0`:
```bash
$ kubectl get pvc
NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
data-my-app-0   Bound    pvc-ad7c6a85-80ec-4cff-97eb-a13d0b7ec7cc   1Gi        RWO            standard       <unset>                 6m45s
data-my-app-1   Bound    pvc-aa3bea1e-0a7b-44bd-bd62-e2a6a63e03cc   1Gi        RWO            standard       <unset>                 6m42s
```

Reading the data:
```bash
$ kubectl exec data-test-app-0 -- cat /data/visits
```

#### Headless Service Access

```bash
$ kubectl exec my-app-0 -- nslookup my-app-1.my-app.default.svc.cluster.local
Server:		10.96.0.10
Address:	10.96.0.10:53


Name:	my-app-1.my-app.default.svc.cluster.local
Address: 10.244.0.48
```

#### Monitoring & Alerts
Probes Implementation
Added to statefulset.yaml:

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 8000
  initialDelaySeconds: 5
  periodSeconds: 10
readinessProbe:
  httpGet:
    path: /
    port: 8000
  initialDelaySeconds: 2
  periodSeconds: 5
Role of Probes:
```
Liveness Probe: Restarts pods if they become unresponsive, ensuring service availability.
Readiness Probe: Prevents traffic to pods during startup or failure, crucial for stateful apps to avoid data corruption during unstable states.
Criticality: Ensures pods handle stateful operations (e.g., database writes) only when fully operational.
Ordering Guarantee and Parallel Operations
Parallel Implementation:
```yaml
spec:
  podManagementPolicy: Parallel
```
This allows simultaneous scaling of pods, improving operational speed.