# Kubernetes StatefulSet

kubectl get po,sts,svc,pvc
```
NAME                                        READY   STATUS      RESTARTS       AGE
pod/myapp-0                                 1/1     Running     0              45s
pod/myapp-1                                 1/1     Running     0              45s

NAME                     READY   AGE
statefulset.apps/myapp   3/3     46s

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/myapp                      NodePort    10.104.164.14    <none>        8000:31131/TCP      46s

NAME                                          STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/myapp-storage-myapp-0   Bound    pvc-6078ca9d-6713-4b07-adba-9c74636bdf94   1Gi        RWO            standard       <unset>                 46s
persistentvolumeclaim/myapp-storage-myapp-1   Bound    pvc-797efc2e-0e50-488c-a106-b66dc036922c   1Gi        RWO            standard       <unset>                 46s
```

# Persistent Storage

Each pod in the StatefulSet maintains an independent Persistent Volume Claim (PVC), ensuring that stored data remains separate across replicas. This means that when traffic is distributed among the pods, each pod updates its own local data store rather than sharing a centralized database.
```
kubectl exec pod/myapp-0 -- cat visits
```
```
7
```
```
kubectl exec pod/myapp-1 -- cat visits
```
```
9
```

The difference in stored values occurs because incoming requests are distributed among multiple pods, each maintaining its own counter. Since the data is not shared across replicas, each pod independently tracks visits, leading to different numbers across instances.

# Headless Service and DNS

kubectl exec myapp-0 -- nslookup myapp-1.myapp.default.svc.cluster.local
```
Server: 10.96.0.10
Address: 10.96.0.10#53

Name: myapp-1.myapp.default.svc.cluster.local
Address: 10.244.0.254
```

kubectl exec myapp-1 -- nslookup myapp-0.myapp.default.svc.cluster.local
```
Server: 10.96.0.10
Address: 10.96.0.10#53

Name: myapp-1.myapp.default.svc.cluster.local
Address: 10.244.0.252
```

# Monitoring & Alerts

## Liveness Probe
- Automatically restarts a pod if it becomes unresponsive or unhealthy.
- Prevents failed instances from remaining in service, improving reliability.

## Readiness Probe
- Ensures that a pod does not receive traffic until it is fully initialized and functional.
- Prevents routing requests to an unready instance, enhancing availability.

These probes are essential for stateful applications, as they ensure that only healthy pods handle traffic, preventing downtime and improving resilience.

# Ordering Guarantee and Parallel Operations

By default, Kubernetes StatefulSets create and terminate pods sequentially (OrderedReady). This is useful for applications requiring ordered startup, such as databases. However, in our case, the Python application does not rely on startup order.

To optimize scaling, I configured the StatefulSet to use Parallel mode, enabling simultaneous creation and termination of pods. This speeds up deployment and shutdown without affecting functionality.

Implementation in ```statefulset.yaml```:
```
spec:
  podManagementPolicy: Parallel
```
With this configuration, all pods can start or terminate simultaneously, ensuring faster scaling operations.
