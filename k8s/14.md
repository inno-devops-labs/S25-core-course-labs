# StatefulSet

### Research and Documentation

Divide the command `kubectl get po,sts,svc,pvc` into several outputs
 
1) List of **Pods** (command and output):
```bash
➞ kubectl get po

NAME                                    READY   STATUS    RESTARTS   AGE
my-app-python-0                         1/1     Running   0          5m36s
my-app-python-1                         1/1     Running   0          5m23s
my-app-python-2                         1/1     Running   0          5m28s
python-app-my-app-hfj45hs45j-hj4f5      1/1     Running   0          52s
```

2) List of **StatefulSets** (command and output):
```bash
➞ kubectl get sts

NAME            READY   AGE
my-app-python   3/3     5m48s
```

3) List of **Services** (command and output):
```bash
➞ kubectl get svc

NAME                     TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
my-app-python            ClusterIP   10.106.123.45    <none>        80/TCP    5m27s
my-app-python-headless   ClusterIP   None             <none>        80/TCP    7m
kubernetes               ClusterIP   10.96.0.1        <none>        443/TCP   13d
python-app-my-app        ClusterIP   10.109.53.101    <none>        80/TCP    22h
```

4) List of **Persistent Volume Claims** (command and output):
```bash
➞ kubectl get pvc

NAME                   STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
data-my-app-python-0   Bound    pvc-gh7fhf77-gh4j-hr7f-ht7d-djgj495ngj7f   1Gi        RWO            standard       7m12s
data-my-app-python-1   Bound    pvc-fhdj3ggu-h786-fg32-fh8f-dgh57hfkd7ll   1Gi        RWO            standard       7m8s
data-my-app-python-2   Bound    pvc-fgh5ydj8-fh78-sh36-fjf8-jg8jsl3gfj98   1Gi        RWO            standard       7m2s
```

### Persistent Storage Validation

Content of the visit file in each pod
```bash
➞ kubectl exec my-app-python-0 -- cat /data/visits
14
➞ kubectl exec my-app-python-1 -- cat /data/visits
12
➞ kubectl exec my-app-python-2 -- cat /data/visits
15
```
Due to the unique PVCs, each StatefulSet pod stores data independently. Because of this, traffic (distributed between pods) stores different data. Data remains separate in different replicas because each pod in StatefulSet has its own persistent storage. The scattering of stored values occurs because requests are distributed among different pods, each of which updates its own visit counter.

### Headless Service Access

```bash
➞ kubectl exec my-app-python-0 -- nslookup my-app-python-1.my-app-python-headless

Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      my-app-python-1.my-app-python-headless
Address 1: 10.244.0.167 10-244-0-167.my-app-python.default.svc.cluster.local
```

### Monitoring & Alerts

1) How probes ensure pod health:

- Liveness Probes:
  - Detect if a container becomes unresponsive or enters a failed state.
  - If the probe fails, Kubernetes automatically restarts the pod, preventing it from being stuck in an unhealthy state.

- Readiness Probes:
  - Ensure that a pod is fully initialized and ready to handle requests before it starts receiving traffic.
  - If the probe fails, the pod is temporarily removed from the service's endpoint list, preventing traffic from being sent to an unprepared application.

2) Why they’re critical for stateful apps:

- Readiness Probes:
  - Ensure that each pod in a StatefulSet is fully functional before it joins the service.
  - Prevent traffic from being routed to incomplete or partially initialized instances, which is especially important for stateful applications that rely on consistent data and initialization processes.
- Liveness Probes:
  - Detect failures in stateful applications and allow Kubernetes to automatically restart problematic pods.
  - Reduce downtime and ensure high availability by quickly recovering from crashes or unresponsive states.
- Stateful Application Considerations:
  - Stateful applications often manage critical data or perform complex initialization tasks. Probes ensure that these tasks are completed successfully before the pod is exposed to traffic.
  - Probes help maintain the integrity and reliability of stateful applications by ensuring that only healthy and fully initialized pods are part of the service.

Summary: Probes maintain application reliability, prevent traffic to incomplete instances, and ensure high availability

### Ordering Guarantee and Parallel Operations

1) Explaination why ordering guarantees are unnecessary for my app:

- Each pod operates independently without relying on others.
- No sequential startup or leader election is needed.
- Strict ordering is unnecessary as pods do not share state or require specific initialization sequences.
- Avoiding ordering speeds up scaling and deployments.

2) Implement a way to instruct the StatefulSet controller to launch or terminate all Pods in parallel:

- Set podManagementPolicy: Parallel in the StatefulSet.
- This allows pods to launch or terminate simultaneously.
- Benefits:
  - Faster scaling and deployments.
  - No impact on functionality since pods work independently.
