# Kubernetes StatefulSet

## Implement StatefulSet in Helm Chart

```txt
(venv) ➜  k8s git:(Lab-14) ✗ helm install python-web-app ./python-web-app
NAME: python-web-app
LAST DEPLOYED: Wed Mar 16 22:38:37 2025
NAMESPACE: default  
STATUS: deployed
REVISION: 1
NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=python-web-app,app.kubernetes.io/instance=python-web-app" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT
```

## StatefulSet Exploration and Optimization

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl get po,sts,svc,pvc
NAME                   READY   STATUS    RESTARTS   AGE
pod/python-web-app-0   1/1     Running   0          16s
pod/python-web-app-1   1/1     Running   0          16s

NAME                              READY   AGE
statefulset.apps/python-web-app   2/2     16s

NAME                     TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/kubernetes       ClusterIP   10.96.0.1        <none>        443/TCP    2m
service/python-web-app   ClusterIP   10.106.161.180   <none>        8000/TCP   16s

NAME                                                    STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/py-visits-data-python-web-app-0   Bound    pvc-64758hg8-d475-869h-5478-o6574dtra34k   512Mi      RWO            standard       <unset>   
              16s
persistentvolumeclaim/py-visits-data-python-web-app-1   Bound    pvc-43675i74-f6w9-436g-g758-953yrhsewp7h   512Mi      RWO            standard       <unset>   
              16s
```

### Persistent Storage Validation

Each pod maintains its own visit count due to separate Persistent Volume Claims. When accessing the application, different pods with their respective volumes are utilized because of load balancing.

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl exec pod/python-web-app-0 -- cat data/visits
153
```

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl exec pod/python-web-app-1 -- cat data/visits
146
```

Let's delete one:

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl delete pod/python-web-app-0
pod "python-web-app-0" deleted
```

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl exec pod/python-web-app-0 -- cat data/visits
162
```

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl get pvc
NAME                              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
py-visits-data-python-web-app-0   Bound    pvc-64758hg8-d475-869h-5478-o6574dtra34k   512Mi      RWO            standard       <unset>                 24m     
py-visits-data-python-web-app-1   Bound    pvc-43675i74-f6w9-436g-g758-953yrhsewp7h   512Mi      RWO            standard       <unset>                 24m   
```

### Headless Service Access

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl exec python-web-app-0 -- nslookup python-web-app-1.python-web-app.default.svc.cluster.local
Server:         10.96.0.10
Address:        10.96.0.10:53

Name:   python-web-app-1.python-web-app.default.svc.cluster.local
Address: 10.244.0.8
```

```txt
(venv) ➜  k8s git:(Lab-14) ✗ kubectl exec python-web-app-1 -- nslookup python-web-app-0.python-web-app.default.svc.cluster.local
Server:         10.96.0.10
Address:        10.96.0.10:53

Name:   python-web-app-0.python-web-app.default.svc.cluster.local
Address: 10.244.0.9
```

### Monitoring & Alerts

```yaml
livenessProbe:
  httpGet:
    path: /
    port: http
readinessProbe:
  httpGet:
    path: /
    port: http
```

- **Liveness Probes** : These checks ensure the pod is operational. If the probe fails, the container is restarted.
- **Readiness Probes** : These ensure traffic is only routed to healthy pods, maintaining stability.
- Both probes are essential for stateful applications to prevent traffic from being directed to unhealthy pods.

### Ordering Guarantee and Parallel Operations

For this application, ordering guarantees were unnecessary because:

- Each pod operates independently with its own PVC.
- There are no dependencies between pods during startup or shutdown.

`podManagementPolicy: Parallel`

This allows all pods to be launched or terminated simultaneously.

## Update Strategies

### Implemented Update Strategies

```yaml
spec:
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 1
```

**RollingUpdate** :
- The RollingUpdate strategy updates pods incrementally, ensuring no downtime. Kubernetes replaces old pods with new ones while preserving their identity (hostname, storage, and network).

Use Cases :
- Suitable for applications that can handle incremental updates without data loss.
- Ideal for distributed databases, message brokers, and other stateful services supporting online upgrades.
- Ensures zero-downtime deployments.

**OnDelete** :
- With the OnDelete strategy, pods are not automatically updated when the StatefulSet definition changes. Instead, updates require manual deletion and recreation of each pod.

Use Cases :
- When you need full control over the update process.
- For stateful applications where automatic updates could lead to data inconsistency or corruption.
- When updates involve manual steps like database migrations.

Compared to Deployments, StatefulSets maintain pod identity and persistent storage, making them ideal for stateful workloads. While Deployments are suited for stateless applications, StatefulSets ensure ordered updates and data persistence, making strategies like OnDelete and RollingUpdate crucial for safe updates.