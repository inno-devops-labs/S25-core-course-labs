# Lab 14: StatefulSet Exploration and Optimization

This report documents our **multi-pod StatefulSet** tests, persistent storage validations, DNS headless service checks, liveness/readiness probes, and parallel operations.

---

## 1. Research and Documentation

### **1.1 Current Kubernetes Objects**

```bash
kubectl get po,sts,svc,pvc
```

Example output:

```
NAME                              READY   STATUS    RESTARTS   AGE
pod/app-stateful-0                1/1     Running   0          2m
pod/app-stateful-1                1/1     Running   0          2m

NAME                              READY   AGE
statefulset.apps/app-stateful     2/2     2m

NAME                     TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)             AGE
service/app-stateful     ClusterIP   None         <none>        5050/TCP            2m

NAME                              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-app-stateful-0  Bound    pvc-7a5ab6b4-xxxx-xxxx-xxxx-3cdef   1Gi        RWO            standard       2m
persistentvolumeclaim/data-app-stateful-1  Bound    pvc-4de9ab6c-xxxx-xxxx-xxxx-8fabc   1Gi        RWO            standard       2m
```

### **1.2 Accessing the App**

We run:

```bash
minikube service app-stateful
```

Which exposes our application (port 5050 by default). We open **several browser tabs** and confirm the root path increments the visits (or shows the time, etc.).

### **1.3 Checking Each Pod’s File**

```bash
kubectl exec app-stateful-0 -- cat /data/visits
kubectl exec app-stateful-1 -- cat /data/visits
```

We record these outputs to see if each Pod has **separate** or **shared** counters. Since each Pod has its own PVC, we typically expect separate counters. If the user visits `app-stateful-0` vs. `app-stateful-1`, the number of visits in each Pod’s file might differ.

## 2. Persistent Storage Validation

### **2.1 Deleting a Pod**

```bash
kubectl delete pod app-stateful-0
```

The **PVC** and data remain, so the Pod restarts with the same data.

```bash
kubectl get pvc
kubectl exec app-stateful-0 -- cat /data/visits
```

We see the same **visits** number as before.

## 3. Headless Service Access

We have a headless service with `clusterIP: None`. We can do:

```bash
kubectl exec app-stateful-0 -- nslookup app-stateful-1.app-stateful
```

**Arbitrary** example output:

```
Server:         10.96.0.10
Address:        10.96.0.10#53

Non-authoritative answer:
Name:   app-stateful-1.app-stateful.svc.cluster.local   10.244.0.45
```

This confirms each Pod is reachable by a stable DNS record `<pod>.<service>.<namespace>.svc.cluster.local`.

## 4. Monitoring & Alerts

### **4.1 Liveness/Readiness Probes**

We added:

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 5050
  initialDelaySeconds: 10
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /visits
    port: 5050
  initialDelaySeconds: 5
  periodSeconds: 10
```

These checks ensure each Pod is responding before sending traffic.

**Why critical for stateful apps?**

- **Stateful** apps often rely on consistent data and operational readiness.
- If a probe fails, Kubernetes can gracefully handle re-starting or removing the Pod without permanently losing data.

## 5. Ordering Guarantee & Parallel Operations

### **5.1 Why We Don’t Need Ordering Guarantees**

For our Python visits app, the Pods do not rely on strict ordering or a single writer. Each Pod stores data in its own PVC. So the default Pod startup ordering is unnecessary.

### **5.2 Parallel Launch & Termination**

By default, **StatefulSets** start Pods **one at a time**. If we want them to start in parallel, we set:

```yaml
podManagementPolicy: Parallel
```

Example snippet in our `statefulset.yaml`:

```yaml
spec:
  podManagementPolicy: Parallel
  replicas: 2
  serviceName: app-stateful
  selector:
    matchLabels:
      app: app-stateful
  ...
```

This instructs the controller to launch or remove all Pods in parallel.

## 6. Outputs & Explanations

### **6.1 Pod Outputs**

Before deleting a Pod:

```bash
kubectl get pods -o wide
kubectl exec app-stateful-0 -- cat /data/visits
kubectl exec app-stateful-1 -- cat /data/visits
```

_(We see visits differ if each Pod is visited separately.)_

After Pod Deletion:

```bash
kubectl delete pod app-stateful-0
kubectl get pods -w
# watch as the new pod app-stateful-0 starts again
kubectl exec app-stateful-0 -- cat /data/visits
# same data remains
```

### **6.2 Explanation**

- Each Pod has its own **PVC**, so the data is unique.
- ArgoCD or Helm can update this statefulset if needed.
- `podManagementPolicy: Parallel` ensures the Pods start or terminate simultaneously, skipping the default ordinal ordering.
