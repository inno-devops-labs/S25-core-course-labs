# Kubernetes StatefulSet

## Task 1,2

The result of command `kubectl get po,sts,svc,pvc`:

```bash
kubectl get po,sts,svc,pvc
NAME                                         READY   STATUS    RESTARTS       AGE
pod/app-python-0                             2/2     Running   0              2m14s
pod/app-python-1                             2/2     Running   1 (64s ago)    99s
pod/vault-0                                  1/1     Running   10 (16h ago)   8d
pod/vault-agent-injector-66f45b5fd5-njvbf    1/1     Running   14 (16h ago)   8d

NAME                          READY   AGE
statefulset.apps/app-python   2/2     2m14s
statefulset.apps/vault        1/1     8d

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-python                 ClusterIP   10.98.25.133     <none>        5000/TCP            2m14s
service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             16d
service/vault                      ClusterIP   10.108.135.195   <none>        8200/TCP,8201/TCP   8d
service/vault-agent-injector-svc   ClusterIP   10.110.170.23    <none>        443/TCP             8d
service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   8d

NAME                                                STATUS   VOLUME                                     CAPACITY  ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/app-python-pvc-app-python-0   Bound    pvc-0e9bcdd8-d76f-498f-8117-7c878091f16d   90Mi       RWO            standard       <unset>                 2m14s
persistentvolumeclaim/app-python-pvc-app-python-1   Bound    pvc-a8182c99-5e76-4842-9902-fc4537cf2f6e   90Mi       RWO            standard       <unset>                 100s
```

The content of `visits.txt` file in pods:

```bash
% kubectl exec app-python-0 -- cat data/visits.txt 
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
74

% kubectl exec app-python-1 -- cat data/visits.txt
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
71
```

Each Pod has its own PersistentVolumeClaim (PVC). This means that each Pod maintains its own local copy of visits.txt and does not share it with others. The ClusterIP service distributes traffic between both Pods.If one Pod receives more requests than the other, its visit count will be higher. Thats why `app-python-0` and `app-python-1` has different number of visits.

### Deletion of pod

```bash
kubectl exec app-python-0 -- cat data/visits.txt
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
172

kubectl delete pod app-python-0
pod "app-python-0" deleted
ilsianasibullina@MacBook-Air-Ilsia app-python % kubectl get po,sts,svc,pvc                      
NAME                                         READY   STATUS     RESTARTS       AGE
pod/app-python-0                             0/2     Init:0/1   0              1s
pod/app-python-1                             2/2     Running    1 (14m ago)    14m
pod/vault-0                                  1/1     Running    10 (16h ago)   8d
pod/vault-agent-injector-66f45b5fd5-njvbf    1/1     Running    14 (16h ago)   8d

NAME                          READY   AGE
statefulset.apps/app-python   1/2     15m
statefulset.apps/vault        1/1     8d

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-python                 ClusterIP   10.98.25.133     <none>        5000/TCP            15m
service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             16d
service/vault                      ClusterIP   10.108.135.195   <none>        8200/TCP,8201/TCP   8d
service/vault-agent-injector-svc   ClusterIP   10.110.170.23    <none>        443/TCP             8d
service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   8d

NAME                                                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/app-python-pvc-app-python-0   Bound    pvc-0e9bcdd8-d76f-498f-8117-7c878091f16d   90Mi       RWO            standard       <unset>                 15m
persistentvolumeclaim/app-python-pvc-app-python-1   Bound    pvc-a8182c99-5e76-4842-9902-fc4537cf2f6e   90Mi       RWO            standard       <unset>                 14m


% kubectl exec app-python-0 -- cat data/visits.txt
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
172
```

As we see, after pod deletion the PVC is not deleted, the new pod is immediately initialized. As the PVC is not deleted the result of visits is the same.

### DNS resolution

The DNS resolution from both pods:

```bash
% kubectl exec app-python-0 -- nslookup app-python-1.app-python                          
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
Server:  10.96.0.10
Address: 10.96.0.10:53

Non-authoritative answer:
Name: app-python-1.app-python
Address: 198.18.0.41

% kubectl exec app-python-0 -- nslookup app-python-1.app-python.default.svc.cluster.local
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
Server:  10.96.0.10
Address: 10.96.0.10:53


Name: app-python-1.app-python.default.svc.cluster.local
Address: 10.244.1.232


% kubectl exec app-python-1 -- nslookup app-python-0.app-python            
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
Server:  10.96.0.10
Address: 10.96.0.10:53

Non-authoritative answer:
Name: app-python-0.app-python
Address: 198.18.0.44

% kubectl exec app-python-1 -- nslookup app-python-0.app-python.default.svc.cluster.local
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
Server:  10.96.0.10
Address: 10.96.0.10:53

Name: app-python-0.app-python.default.svc.cluster.local
Address: 10.244.1.233
```

### Liveness and readiness

Liveness and readiness probes help ensure pod health by automatically detecting failures and preventing traffic from being sent to unhealthy instances. Liveness probes restart pods that become unresponsive, while readiness probes ensure that only fully initialized pods receive traffic. These are especially critical for stateful applications, as they maintain unique data and connections, requiring careful handling during restarts to prevent disruptions and data inconsistencies.

### Ordering Guarantee and Parallel Operations

Ordering guarantees are unnecessary for my app because it does not rely on strict sequencing of operations; each instance functions independently without needing a specific startup or shutdown order. Thats why I can start them in parallel.
However, ordering guarantees are essential in distributed databases, leader-election systems, and applications managing transactional workflows, where operations must follow a strict sequence to prevent data inconsistencies, race conditions, or conflicts.

## Bonus

StatefulSet to Bonus App:

```bash
kubectl get po,sts,svc,pvc
NAME                                         READY   STATUS    RESTARTS       AGE
pod/app-nodejs-0                             1/1     Running   0              32s
pod/app-nodejs-1                             1/1     Running   0              32s
pod/app-python-0                             2/2     Running   0              10m
pod/app-python-1                             2/2     Running   0              10m
pod/vault-0                                  1/1     Running   10 (17h ago)   8d
pod/vault-agent-injector-66f45b5fd5-njvbf    1/1     Running   14 (17h ago)   8d

NAME                          READY   AGE
statefulset.apps/app-nodejs   2/2     33s
statefulset.apps/app-python   2/2     14m
statefulset.apps/vault        1/1     8d

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-nodejs                 ClusterIP   10.100.114.208   <none>        3001/TCP            33s
service/app-python                 ClusterIP   10.104.188.233   <none>        5000/TCP            14m
service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             16d
service/vault                      ClusterIP   10.108.135.195   <none>        8200/TCP,8201/TCP   8d
service/vault-agent-injector-svc   ClusterIP   10.110.170.23    <none>        443/TCP             8d
service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   8d

NAME                                                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/app-nodejs-pvc-app-nodejs-0   Bound    pvc-9d3010fb-f669-46df-99c5-f9b391c42fe6   90Mi       RWO            standard       <unset>                 32s
persistentvolumeclaim/app-nodejs-pvc-app-nodejs-1   Bound    pvc-76f1ecda-9430-4190-a028-3dd2c55a04ee   90Mi       RWO            standard       <unset>                 32s
persistentvolumeclaim/app-python-pvc-app-python-0   Bound    pvc-0e9bcdd8-d76f-498f-8117-7c878091f16d   90Mi       RWO            standard       <unset>                 74m
persistentvolumeclaim/app-python-pvc-app-python-1   Bound    pvc-a8182c99-5e76-4842-9902-fc4537cf2f6e   90Mi       RWO            standard       <unset>       
```

### OnDelete vs. RollingUpdate in StatefulSets

OnDelete: Updates do not happen automatically. New versions of a pod are only created when manually deleted. This strategy is useful when manual control over pod updates is required, such as in databases where schema migrations or leader elections must be handled carefully.

RollingUpdate: Pods are updated one at a time (or in batches, depending on configuration). This allows for zero downtime and ensures that the application remains available. It’s ideal for most stateful applications that require seamless updates while maintaining data integrity.

### Comparison with Deployment update strategies

- Deployments use RollingUpdate by default, replacing pods gradually while ensuring availability.
- Deployments also support Recreate, which deletes all old pods at once before creating new ones—suitable for stateless apps that don’t need persistent storage.
- StatefulSets don’t support Recreate because they manage persistent storage and need to maintain identity across updates.
