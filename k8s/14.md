# Lab 14: Kubernetes StatefulSet

## Kubernetes Resource Overview

### Pods:

```bash
kubectl get po
```

```bash
NAME                                 READY   STATUS    RESTARTS   AGE
app-my-app-0                         1/1     Running   0          3m37s
app-my-app-1                         1/1     Running   0          3m33s
app-my-app-2                         1/1     Running   0          3m28s
python-app-my-app-5f6fd64cbb-z5x4p   1/1     Running   0          87s
```

### StatefulSets:

```bash
kubectl get sts
```

```bash
NAME         READY   AGE
app-my-app   3/3     3m48s
```

### Services:

```bash
kubectl get svc
```

```bash
NAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
app-my-app            ClusterIP   10.106.118.233   <none>        80/TCP    3m57s
app-my-app-headless   ClusterIP   None             <none>        80/TCP    3m
kubernetes            ClusterIP   10.96.0.1        <none>        443/TCP   13d
python-app-my-app     ClusterIP   10.109.53.228    <none>        80/TCP    17h
```

### Persistent Volume Claims (PVCs):

```bash
kubectl get pvc
```

```bash
NAME                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
data-app-my-app-0   Bound    pvc-58c0ff82-90f6-4ca2-b803-a82ac6b6c92a   1Gi        RWO            standard       4m8s
data-app-my-app-1   Bound    pvc-4bf57afa-90bd-4ab6-9d9f-1582a7a4631c   1Gi        RWO            standard       4m4s
data-app-my-app-2   Bound    pvc-329515f5-b650-4922-93b9-affa77dade68   1Gi        RWO            standard       4m
```

## Persistent Storage Validation

Each pod in the StatefulSet stores data independently due to unique PVCs. This means that traffic distributed among pods results in different data being stored. Below are the contents of the `visits` file in each pod:

```bash
kubectl exec app-my-app-0 -- cat /data/visits
```

```bash
7
```

```bash
kubectl exec app-my-app-1 -- cat /data/visits
```

```bash
5
```

```bash
kubectl exec app-my-app-2 -- cat /data/visits
```

```bash
11
```

Since each pod in the StatefulSet has its own persistent storage, data remains separate across replicas. Requests are distributed among different pods, each updating its own `visits` count, which explains the variation in stored values.

## Headless Service Access and DNS Resolution

```bash
kubectl exec app-my-app-0 -- nslookup app-my-app-1.app-my-app-headless
```

```bash
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      app-my-app-1.app-my-app-headless
Address 1: 10.244.0.177 10-244-0-177.app-my-app.default.svc.cluster.local
```

## Probes for Stateful Apps

Liveness probes detect if a container becomes unresponsive and restart it if needed. This prevents pods from being stuck in a failed state.

Readiness probes ensure that a pod is fully initialized before it starts receiving traffic. This prevents requests from being sent to an application that is not yet ready to process them.

For stateful applications, probes are critical. Readiness probes ensure that each pod is functional before it joins the service, preventing traffic from reaching incomplete instances. Liveness probes detect failures and allow Kubernetes to automatically restart problematic pods, reducing downtime and ensuring high availability.

## Parallel Pod Management

My application does not require ordered pod creation because each pod functions independently. There is no need for sequential startup or leader election, so enforcing strict ordering is unnecessary. Enabling parallel pod management speeds up scaling and deployments, making the process more efficient without impacting functionality.

