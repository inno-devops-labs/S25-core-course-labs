# Lab 14: Kubernetes StatefulSet

## Task 2: StatefulSet Exploration and Optimization

### Output of kubectl get po,sts,svc,pvc for default namespace:
```bash 
> kubectl get po,sts,svc,pvc
NAME                                             READY   STATUS    RESTARTS      AGE
pod/moscow-time-app-moscow-time-app-0            1/1     Running   0             5m39s
pod/moscow-time-app-moscow-time-app-1            1/1     Running   0             5m32s
pod/my-app-moscow-time-app-dcb96c96c-2hz65       1/1     Running   2 (56m ago)   44h
pod/python-app-moscow-time-app-58bc47dc5-7xl6h   1/1     Running   2 (56m ago)   43h
pod/python-app-moscow-time-app-58bc47dc5-d77ls   1/1     Running   2 (56m ago)   44h

NAME                                               READY   AGE
statefulset.apps/moscow-time-app-moscow-time-app   2/2     5m39s

NAME                                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
service/kubernetes                        ClusterIP   10.96.0.1       <none>        443/TCP    2d18h
service/moscow-time-app                   ClusterIP   None            <none>        8000/TCP   5m39s
service/moscow-time-app-moscow-time-app   ClusterIP   None            <none>        8000/TCP   55m
service/my-app-moscow-time-app            ClusterIP   10.105.60.230   <none>        8000/TCP   44h
service/python-app-moscow-time-app        ClusterIP   10.97.18.191    <none>        8000/TCP   2d16h

NAME                                                           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/data-moscow-time-app-moscow-time-app-0   Bound    pvc-de4509f1-4675-4bbd-b124-7c53f4278a94   1Gi        RWO            standard       <unset>                 5m39s
persistentvolumeclaim/data-moscow-time-app-moscow-time-app-1   Bound    pvc-6e913b00-4d3d-4f32-aec4-e7045fdaae26   1Gi        RWO            standard       <unset>                 5m32s
```
### Visit count for different pods:

!['count_pod.png'](/k8s/lab14_images/count_pod.png)
The visit counts differ across pods because the load balancer distributes requests randomly, and each pod in the StatefulSet maintains its own visits.txt file stored in a distinct PersistentVolume. As these files are not shared, each pod updates its own counter independently. StatefulSets ensure that each pod has isolated storage, so to synchronize the visit counts, a shared database or similar centralized storage solution would be required.

### Persistent storage validation 
![persistent_storage_validation.png](/k8s/lab14_images/persistent_storage_validation_.png)

### Headless Service Access
![nslookup.png](/k8s/lab14_images/nslookup_.png)

### Monitoring & Alerts

To ensure the health and availability of the `moscow-time-app` pods, I’ve added liveness and readiness probes to the StatefulSet configuration.

- **Liveness Probe**: 
  - Checks the root path (`/`) every 10 seconds after an initial delay of 30 seconds using an HTTP GET request.
  - If the probe fails (i.e., the path is unresponsive), Kubernetes restarts the pod. This ensures that only healthy pods remain operational, maintaining application availability.

- **Readiness Probe**: 
  - Checks the root path (`/`) every 5 seconds after an initial delay of 5 seconds using an HTTP GET request.
  - Ensures the pod is marked as "ready" only when it can successfully respond, preventing traffic from being routed to pods that aren’t fully operational.

**Importance for Stateful Applications**:  
These probes are critical for stateful applications because they help maintain data consistency. By restarting unhealthy pods (via the liveness probe) and only routing traffic to fully operational pods (via the readiness probe), we reduce the risk of data corruption or inconsistencies that could occur if compromised pods were allowed to process requests.

---


### Ordering Guarantee and Parallel Operations
In the context of the `moscow-time-app`, the pods are independent and do not rely on leader election or sequential startup/shutdown processes. As a result, the strict ordering guarantees provided by the default `OrderedReady` pod management policy are not necessary for this application.

### Parallel Operations
To optimize performance, I updated the StatefulSet’s `podManagementPolicy` to `Parallel`.  
- **Default Behavior**: The default `OrderedReady` policy launches and terminates pods sequentially, ensuring each pod is ready before starting the next.
- **Parallel Behavior**: With `Parallel`, all pods are launched or terminated simultaneously. This speeds up scaling operations and reduces downtime during updates, as pods don’t need to wait for each other to start or stop.

This configuration is ideal for the `moscow-time-app` since its pods can operate independently without depending on the state or readiness of other pods.