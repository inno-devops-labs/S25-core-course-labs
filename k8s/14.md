# Kubernetes StatefulSet

## StatefulSet Exploration and Optimization

```bash
> kubectl get po,sts,svc,pvc
NAME                                         READY   STATUS    RESTARTS     AGE
pod/app-go-0                                 1/1     Running   0            3m16s
pod/app-python-0                             1/1     Running   0            15m
pod/app-python-1                             1/1     Running   0            15m
pod/go-app-app-go-7c94895c89-bz4f9           1/1     Running   0            23h
pod/python-app-app-python-5b7b769dd8-2lz5m   1/1     Running   0            23h
pod/python-app-app-python-5b7b769dd8-fscwf   1/1     Running   0            23h
pod/vault-0                                  1/1     Running   1 (9d ago)   10d
pod/vault-agent-injector-66f45b5fd5-bddb2    1/1     Running   1 (9d ago)   10d

NAME                          READY   AGE
statefulset.apps/app-go       1/1     3m16s
statefulset.apps/app-python   2/2     15m
statefulset.apps/vault        1/1     10d

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-go                     ClusterIP   10.97.77.114     <none>        8080/TCP            3m16s
service/app-python                 ClusterIP   10.97.226.54     <none>        5000/TCP            15m
service/go-app-app-go              ClusterIP   10.109.61.210    <none>        8080/TCP            23h
service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             18d
service/python-app-app-python      ClusterIP   10.101.209.247   <none>        5000/TCP            23h
service/vault                      ClusterIP   10.110.35.223    <none>        8200/TCP,8201/TCP   10d
service/vault-agent-injector-svc   ClusterIP   10.99.220.181    <none>        443/TCP             10d
service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   10d

NAME                                                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/app-go-data-app-go-0           Bound    pvc-0d214739-31d2-4338-9171-f822c57cd57e   1Gi        RWO            standard       <unset>                 3m16s
persistentvolumeclaim/app-python-data-app-python-0   Bound    pvc-a882674a-1703-4117-b944-6517aeb008d1   1Gi        RWO            standard       <unset>                 15m
persistentvolumeclaim/app-python-data-app-python-1   Bound    pvc-6c421058-e62a-49c6-9195-f9e2624f9c69   1Gi        RWO            standard       <unset>                 15m
```

```bash
> kubectl exec pod/app-python-0 -- cat visits/visits.txt
2
> kubectl exec pod/app-python-1 -- cat visits/visits.txt
7
```

Each replica has a different visit count because they don't share the same storage. Kubernetes assigns separate ephemeral storage to each pod unless a shared volume (like a PersistentVolume) is used. So, app-python-0 and app-python-1 are maintaining their own independent counters, leading to different values.

```bash
> kubectl delete pod app-python-0
pod "app-python-0" deleted
> kubectl get pvc
NAME                           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
app-go-data-app-go-0           Bound    pvc-0d214739-31d2-4338-9171-f822c57cd57e   1Gi        RWO            standard       <unset>                 27m
app-python-data-app-python-0   Bound    pvc-a882674a-1703-4117-b944-6517aeb008d1   1Gi        RWO            standard       <unset>                 39m
app-python-data-app-python-1   Bound    pvc-6c421058-e62a-49c6-9195-f9e2624f9c69   1Gi        RWO            standard       <unset>                 39m

> kubectl exec pod/app-python-0 -- cat visits/visits.txt
2
```

## Headless Service Access

```bash
> kubectl exec app-python-0 -- nslookup app-python-1.app-python.default.svc.cluster.local

Server:		10.96.0.10
Address:	10.96.0.10#53

Name:	app-python-1.app-python.default.svc.cluster.local
Address: 10.244.0.155
```

### How probes ensure pod health

Liveness and readiness probes in Kubernetes ensure pod health by checking if a pod is alive and ready to handle traffic. The liveness probe restarts the pod if it’s unhealthy, while the readiness probe ensures traffic is only routed to healthy pods. These checks help maintain application reliability by automatically recovering from issues and ensuring only functional pods serve traffic.

### Why they’re critical for stateful apps

Liveness and readiness probes are critical for stateful applications because they ensure pod health and prevent unhealthy pods from receiving traffic.

## Ordering Guarantee and Parallel Operations

### Explain why ordering guarantees are unnecessary for your app

Ordering guarantees are unnecessary for my app because each pod maintains its own visit count on its attached persistent volume, and their states are independent of one another.

## Bonus

```bash
> kubectl get po,sts,svc,pvc
NAME                                         READY   STATUS    RESTARTS     AGE
pod/app-go-0                                 1/1     Running   0            93m
pod/app-python-0                             1/1     Running   0            24m
pod/app-python-1                             1/1     Running   0            24m
pod/go-app-app-go-7c94895c89-bz4f9           1/1     Running   0            24h
pod/python-app-app-python-5b7b769dd8-2lz5m   1/1     Running   0            25h
pod/python-app-app-python-5b7b769dd8-fscwf   1/1     Running   0            25h
pod/vault-0                                  1/1     Running   1 (9d ago)   10d
pod/vault-agent-injector-66f45b5fd5-bddb2    1/1     Running   1 (9d ago)   10d

NAME                          READY   AGE
statefulset.apps/app-go       1/1     93m
statefulset.apps/app-python   2/2     24m
statefulset.apps/vault        1/1     10d

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-go                     ClusterIP   10.97.77.114     <none>        8080/TCP            93m
service/app-python                 ClusterIP   10.99.28.203     <none>        5000/TCP            24m
service/go-app-app-go              ClusterIP   10.109.61.210    <none>        8080/TCP            24h
service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             18d
service/python-app-app-python      ClusterIP   10.101.209.247   <none>        5000/TCP            25h
service/vault                      ClusterIP   10.110.35.223    <none>        8200/TCP,8201/TCP   10d
service/vault-agent-injector-svc   ClusterIP   10.99.220.181    <none>        443/TCP             10d
service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   10d

NAME                                                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/app-go-data-app-go-0           Bound    pvc-0d214739-31d2-4338-9171-f822c57cd57e   1Gi        RWO            standard       <unset>                 93m
persistentvolumeclaim/app-python-data-app-python-0   Bound    pvc-a882674a-1703-4117-b944-6517aeb008d1   1Gi        RWO            standard       <unset>                 105m
persistentvolumeclaim/app-python-data-app-python-1   Bound    pvc-6c421058-e62a-49c6-9195-f9e2624f9c69   1Gi        RWO            standard       <unset>                 105m
```

## Explain OnDelete, RollingUpdate, and their use cases

**OnDelete**: Pods are deleted and recreated manually one by one. This is useful when you need control over pod deletions or when specific conditions must be met before a pod restart.

**RollingUpdate**: Pods are updated gradually, one or a few at a time, ensuring some pods are always running. This strategy is ideal for minimizing downtime and maintaining availability, especially for stateless applications.
