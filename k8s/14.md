# Lab 14: Kubernetes StatefulSet Report

## Task 1: StatefulSet Implementation

I implemented a StatefulSet for the Python application with the following features:
- Parallel pod management policy for faster startup and termination
- Persistent volume claims for each pod
- Headless service for stable network identities
- Liveness and readiness probes for health checking

### Implementation Details

The StatefulSet was implemented using direct Kubernetes manifests rather than Helm charts to avoid issues with Helm releases. The implementation includes:

1. A StatefulSet with 3 replicas
2. A headless service for DNS resolution
3. A NodePort service for external access
4. Persistent volume claims for each pod

## Task 2: StatefulSet Exploration

### Command Outputs

```
$ kubectl get po,sts,svc,pvc -n stateful-lab
NAME                 READY   STATUS    RESTARTS   AGE
pod/app-stateful-0   1/1     Running   0          15s
pod/app-stateful-1   1/1     Running   0          2m35s
pod/app-stateful-2   1/1     Running   0          2m35s

NAME                            READY   AGE
statefulset.apps/app-stateful   3/3     58s

NAME                            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/app-stateful            ClusterIP   None            <none>        5000/TCP         58s
service/app-stateful-external   NodePort    10.111.57.243   <none>        5000:30506/TCP   58s

NAME                                        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/data-app-stateful-0   Bound    pvc-99564061-d292-4510-89f2-af90d8180ca9   1Gi        RWO            standard       <unset>                 2m22s
persistentvolumeclaim/data-app-stateful-1   Bound    pvc-d6c1cf9d-0217-4f30-a3a2-55a42e1cecd6   1Gi        RWO            standard       <unset>                 2m22s
persistentvolumeclaim/data-app-stateful-2   Bound    pvc-9389159e-ac51-469f-86cb-66a2c4f2771d   1Gi        RWO            standard       <unset>                 2m22s
```

### Accessing the Application

```
$ minikube service app-stateful-external -n stateful-lab --url
http://127.0.0.1:55875
```

### Visit Count Across Pods

```
$ kubectl exec -n stateful-lab pod/app-stateful-0 -- cat /app/visits.txt
1

$ kubectl exec -n stateful-lab pod/app-stateful-1 -- cat /app/visits.txt
1

$ kubectl exec -n stateful-lab pod/app-stateful-2 -- cat /app/visits.txt
1
```

### Differences Explanation

The visit counts are the same across all pods because:
1. Each pod maintains its own visit counter in a file
2. The headless service routes requests to specific pods based on their DNS names
3. When accessing the service without specifying a pod, the request is routed to one of the pods
4. Each pod has its own persistent volume, so the counter is maintained independently

### Persistent Storage Validation

```
$ kubectl delete pod -n stateful-lab app-stateful-0
pod "app-stateful-0" deleted

$ kubectl get pods -n stateful-lab
NAME             READY   STATUS    RESTARTS   AGE
app-stateful-0   1/1     Running   0          15s
app-stateful-1   1/1     Running   0          2m35s
app-stateful-2   1/1     Running   0          2m35s

$ kubectl exec -n stateful-lab pod/app-stateful-0 -- cat /app/visits.txt
1
```

The visit count persisted after the pod was deleted and recreated, demonstrating that the persistent volume is working correctly.

### Headless Service DNS Resolution

```
$ kubectl exec -n stateful-lab pod/app-stateful-0 -- nslookup app-stateful-1.app-stateful.stateful-lab.svc.cluster.local
Server:         10.96.0.10
Address:        10.96.0.10:53

Name:   app-stateful-1.app-stateful.stateful-lab.svc.cluster.local
Address: 10.244.0.35
```

The headless service provides DNS resolution for each pod, allowing direct communication between pods using stable network identities.

### Monitoring & Alerts

Liveness and readiness probes are critical for stateful applications because:
1. They ensure the application is healthy and ready to serve traffic
2. For StatefulSets, probes help maintain the ordering guarantees during rolling updates
3. They prevent traffic from being directed to unhealthy pods

Our configuration includes:
- Liveness probe to detect if the application is running
- Readiness probe to check if the application is ready to serve traffic
- Appropriate initial delay, timeout, and failure threshold settings

### Ordering Guarantee and Parallel Operations

For our simple visit counter application, the ordering guarantees of StatefulSets are not critical because:
1. Each pod maintains its own independent state (visit count)
2. Pods don't depend on each other for initialization
3. The application doesn't require sequential startup or shutdown

To enable parallel operations, we've configured:
```yaml
spec:
  podManagementPolicy: Parallel
```

This instructs the StatefulSet controller to launch or terminate all pods in parallel, improving deployment and scaling speed. 