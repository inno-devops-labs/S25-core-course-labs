```bash
kubectl get po,sts,svc,pvc
NAME                                         READY   STATUS    RESTARTS        AGE
pod/app-python-0                             1/1     Running   0               7m38s
pod/app-python-1                             1/1     Running   0               7m38s
pod/python-app-app-python-6bc84d4f49-2r7gf   1/1     Running   0               92m
pod/python-app-app-python-6bc84d4f49-m42sz   1/1     Running   0               99m
pod/vault-0                                  1/1     Running   1 (7h33m ago)   46h

NAME                          READY   AGE
statefulset.apps/app-python   2/2     7m38s
statefulset.apps/vault        1/1     8d

NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-python                 ClusterIP   10.105.88.50     <none>        5000/TCP            7m38s
service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             17d
service/vault                      ClusterIP   10.103.51.105    <none>        8200/TCP,8201/TCP   8d
service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   8d
NAME                                                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/app-python-data-app-python-0   Bound    pvc-0e20d9bf-3d26-4d9a-8553-881625044308   1Gi        RWO            standard       <unset>                 7m38s
persistentvolumeclaim/app-python-data-app-python-1   Bound    pvc-2a522944-1827-4c4a-b563-9457186f3f5a   1Gi        RWO            standard       <unset>                 7m38s
```

```bash
kubectl exec pod/app-python-0 -- cat visits/visits.txt
4

kubectl exec pod/app-python-1 -- cat visits/visits.txt
15
```

The values are different because each pod uses its own persistent volume with a visits file, and these files are not shared between pods.

```bash
kubectl delete pod app-python-0
pod "app-python-0" deleted

kubectl get pvc
NAME                           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
app-python-data-app-python-0   Bound    pvc-0e20d9bf-3d26-4d9a-8553-881625044308   1Gi        RWO            standard       <unset>                 23m
app-python-data-app-python-1   Bound    pvc-2a522944-1827-4c4a-b563-9457186f3f5a   1Gi        RWO            standard       <unset>                 23m

kubectl exec pod/app-python-0 -- cat visits/visits.txt
4
```

```bash
kubectl apply -f https://k8s.io/examples/admin/dns/dnsutils.yaml
pod/dnsutils created

kubectl get pods dnsutils
NAME       READY   STATUS    RESTARTS   AGE
dnsutils   1/1     Running   0          117s

kubectl exec -i -t dnsutils -- nslookup app-python-0.app-python.default.svc.cluster.local
Server:         10.96.0.10
Address:        10.96.0.10#53

Name:   app-python-0.app-python.default.svc.cluster.local
Address: 10.244.0.105

kubectl exec -i -t dnsutils -- nslookup app-python-1.app-python.default.svc.cluster.local
Server:         10.96.0.10
Address:        10.96.0.10#53

Name:   app-python-1.app-python.default.svc.cluster.local
Address: 10.244.0.103
```

### How probes ensure pod health

Probes send an HTTP GET request to the app to check if it's running. If Liveness Probe doesn't get an OK response, 
then Kuber will restart the pod. If Readiness Probe doesn't get an OK response, Kuber will remove the 
pod from the service until it recover.

### Why they’re critical for stateful apps

Probes check that pods only get traffic when they are able to handle it correctly and 
readiness probes check that pods do something only when they are fully ready.

### Explain why ordering guarantees are unnecessary for your app.

Each pod keeps its own visit counter, so pods don’t depend on each other for data. 
Moreover, there’s no leader-follower setup, and no need for one pod to be ready before the others.