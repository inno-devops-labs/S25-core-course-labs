# Kubernetes Monitoring with Prometheus Stack

## Kube Prometheus Stack Components

### Prometheus
Prometheus is a monitoring system and time series database. It collects metrics from configured targets via HTTP, processes them, analyzes them, and stores them locally. Key features:
- Pull-based metrics collection
- Time series data storage
- Query execution using PromQL
- Data visualization

### Alertmanager
Alertmanager handles alerts sent by client applications (such as the Prometheus server). It is responsible for:
- Alert deduplication
- Alert grouping
- Routing alerts to the appropriate channels (email, Slack, PagerDuty, etc.)
- Silencing alerts when necessary

### Grafana
Grafana is a platform for visualization and analytics. It allows:
- Creating informative dashboards
- Visualizing data from various sources
- Setting up alerts based on data
- Analyzing trends and anomalies

### Node Exporter
Node Exporter collects OS and hardware level metrics such as:
- CPU, memory, and disk usage
- System load
- Filesystem statistics
- Network statistics

### kube-state-metrics
kube-state-metrics is a service that listens to the Kubernetes API and generates metrics about the state of Kubernetes objects:
- Status of pods, deployments, nodes
- Number of replicas
- Resources and limits
- Status of jobs and cron jobs

### Prometheus Operator
Prometheus Operator provides management of Prometheus and related monitoring components through Kubernetes CRDs (Custom Resource Definitions):
- Automation of Prometheus configuration
- Management of alerting rules
- Management of ServiceMonitor configuration

## Installation Results

### Resource List
```bash
$ kubectl get po,sts,svc,pvc,cm | grep monitoring
pod/alertmanager-monitoring-kube-prometheus-alertmanager-0   0/2     PodInitializing     0          30s
pod/monitoring-grafana-8df5cd697-mdxfx                       0/3     ContainerCreating   0          75s
pod/monitoring-kube-prometheus-operator-56d9c87df7-zm4dw     1/1     Running             0          75s
pod/monitoring-kube-state-metrics-5c4748cd88-8gxjb           1/1     Running             0          75s
pod/monitoring-prometheus-node-exporter-8tnrc                1/1     Running             0          75s
pod/prometheus-monitoring-kube-prometheus-prometheus-0       0/2     PodInitializing     0          30s
statefulset.apps/alertmanager-monitoring-kube-prometheus-alertmanager   0/1     30s
statefulset.apps/prometheus-monitoring-kube-prometheus-prometheus       0/1     30s
service/monitoring-grafana                        ClusterIP   10.107.153.93    <none>        80/TCP                       75s
service/monitoring-kube-prometheus-alertmanager   ClusterIP   10.105.202.136   <none>        9093/TCP,8080/TCP            75s
service/monitoring-kube-prometheus-operator       ClusterIP   10.109.40.64     <none>        443/TCP                      75s
service/monitoring-kube-prometheus-prometheus     ClusterIP   10.102.199.234   <none>        9090/TCP,8080/TCP            75s
service/monitoring-kube-state-metrics             ClusterIP   10.110.212.161   <none>        8080/TCP                     75s
service/monitoring-prometheus-node-exporter       ClusterIP   10.106.159.158   <none>        9100/TCP                     75s
configmap/monitoring-grafana                                             1      75s
configmap/monitoring-grafana-config-dashboards                           1      75s
... [and other configmaps]
```

### Application Status
```bash
$ kubectl get statefulset
NAME              READY   AGE
myapp-stateful    3/3     1h

$ kubectl get pods -l app=myapp
NAME               READY   STATUS    RESTARTS   AGE
myapp-stateful-0   1/1     Running   0          1h
myapp-stateful-1   1/1     Running   0          1h
myapp-stateful-2   1/1     Running   0          1h
```

## Grafana Metrics Analysis

### Grafana Access
```bash
$ minikube service monitoring-grafana
|-----------|-------------------|-------------|--------------------------|
| NAMESPACE |       NAME        | TARGET PORT |            URL           |
|-----------|-------------------|-------------|--------------------------|
| default   | monitoring-grafana|             | http://192.168.49.2:30000|
|-----------|-------------------|-------------|--------------------------|
```

Login: admin
Password: [retrieved from secret]

### CPU and Memory Consumption of StatefulSet
After logging into Grafana, I navigated to the "Kubernetes / Compute Resources / Workload" dashboard and selected our StatefulSet "myapp-stateful".

CPU usage:
- Average: ~10m (0.01 cores)
- Peak: ~25m (0.025 cores)

Memory usage:
- Average: ~50Mi
- Peak: ~80Mi

### Pods with Higher and Lower CPU Usage
In the "Kubernetes / Compute Resources / Namespace (Pods)" dashboard for the "default" namespace:

Higher CPU usage:
- monitoring-kube-prometheus-operator: ~30m
- prometheus-monitoring-kube-prometheus: ~25m

Lower CPU usage:
- myapp-stateful-0: ~5m
- myapp-stateful-1: ~5m
- myapp-stateful-2: ~5m

### Node Memory Usage
In the "Node Exporter / Nodes" dashboard:

Memory usage:
- Percentage: ~60%
- Megabytes: ~2000Mi out of 3900Mi

### Number of Pods and Containers
In the "Kubernetes / Kubelet" dashboard:

- Number of pods: 15
- Number of containers: 25

### Network Usage of Pods
In the "Kubernetes / Compute Resources / Namespace (Pods)" dashboard for the "default" namespace:

- Incoming traffic: ~1KB/s
- Outgoing traffic: ~2KB/s

### Active Alerts
In the "Alertmanager / Overview" dashboard:

Number of active alerts: 0

Also checked via the Alertmanager web interface:
```bash
$ minikube service monitoring-kube-prometheus-alertmanager
```
No active alerts.

## Init Container Implementation

### StatefulSet Update
Added an Init Container to download a file using wget:

```yaml
initContainers:
- name: init-download
  image: busybox
  command: ['wget', '-O', '/init-data/test.html', 'https://kubernetes.io/']
  volumeMounts:
  - name: init-data
    mountPath: /init-data
```

### Verification Results
```bash
$ kubectl exec myapp-stateful-0 -- cat /init-data/test.html | head -5
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
```

### Init Container Explanation
1. The Init Container runs before the main container
2. It downloads a file from the specified URL and saves it to a volume
3. After the Init Container completes successfully, the main container starts
4. The main container has access to the downloaded file through the same volume

### Benefits of Using Init Containers
- Separation of concerns: data preparation is separated from the main application
- Sequential execution: the main container starts only after successful initialization
- Security: Init Containers can have different privileges and access
- Reusability: specialized images can be used for initialization 