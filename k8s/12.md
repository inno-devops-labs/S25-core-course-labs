# Kubernetes ConfigMaps and Application Persistence

This document outlines the process for enhancing both our Python and Node.js applications with persistent visit counters and external configuration management using Kubernetes ConfigMaps. It also covers mounting these configurations into our applications and loading them as environment variables. All steps, code templates, and command outputs are detailed below.

---

## Step 1: Application Upgrade for Persistence

### 1.1 Implementing Visit Counter Logic

Both applications have been modified to maintain a visit counter that is stored in a persistent file. Each time the main endpoint is accessed, the counter is incremented and saved.

#### Python Application

In your `main.py`, add functions to read and update the visit count, and expose a new `/visits` endpoint:

```python
import os
from flask import Flask, Response
from datetime import datetime
import pytz
from prometheus_client import (
    CollectorRegistry,
    Gauge,
    generate_latest,
    CONTENT_TYPE_LATEST
)

app = Flask(__name__)

# Prometheus registry and gauge metric setup
registry = CollectorRegistry()
current_time_gauge = Gauge(
    'current_moscow_time',
    'Current time in Moscow as a Unix timestamp',
    registry=registry
)

# File path for persisting the visit counter
VISITS_FILE = 'visits'

def get_visits():
    """Read the current visit count from the persistent file."""
    if os.path.exists(VISITS_FILE):
        try:
            with open(VISITS_FILE, 'r') as f:
                return int(f.read().strip())
        except ValueError:
            return 0
    return 0

def update_visits():
    """Increment the visit count and save it to the file."""
    count = get_visits() + 1
    with open(VISITS_FILE, 'w') as f:
        f.write(str(count))
    return count

@app.route('/')
def show_moscow_time():
    # Get the current time in Moscow
    moscow_tz = pytz.timezone('Europe/Moscow')
    current_time = datetime.now(moscow_tz)
    current_time_str = current_time.strftime('%Y-%m-%d %H:%M:%S')
    # Update the Prometheus gauge with the current timestamp (in seconds)
    current_time_gauge.set(current_time.timestamp())
    # Update visit counter
    update_visits()
    return (
        f"<h1>Welcome to my Python Web App!</h1>"
        f"<h1>Current Time in Moscow: {current_time_str} MSK</h1>"
    )

@app.route('/visits')
def visits():
    """Return the current number of visits."""
    count = get_visits()
    return f"<h2>Number of visits: {count}</h2>"

@app.route('/metrics')
def metrics():
    # Expose Prometheus metrics
    data = generate_latest(registry)
    return Response(data, mimetype=CONTENT_TYPE_LATEST)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

```

#### Node.js Application

In your `server.js`, incorporate logic to read and update the visit counter and add a `/visits` endpoint:

```javascript
const express = require('express');
const fs = require('fs');
const path = require('path');
const app = express();
const client = require('prom-client');

// Set up Prometheus metrics registry and collect default metrics
const register = new client.Registry();
client.collectDefaultMetrics({ register });

// Create a custom gauge metric for current Moscow time (in seconds)
const currentTimeGauge = new client.Gauge({
  name: 'current_moscow_time',
  help: 'Current time in Moscow as a Unix timestamp',
});
register.registerMetric(currentTimeGauge);

// File path for persisting the visit counter
const VISITS_FILE = 'visits';

// Helper function to format the date in 'YYYY-MM-DD HH:MM:SS' format
function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

// Functions to read and update visit counter
function getVisits() {
  try {
    if (fs.existsSync(VISITS_FILE)) {
      const data = fs.readFileSync(VISITS_FILE, 'utf8');
      return parseInt(data, 10) || 0;
    }
    return 0;
  } catch (err) {
    return 0;
  }
}

function updateVisits() {
  const count = getVisits() + 1;
  fs.writeFileSync(VISITS_FILE, count.toString(), 'utf8');
  return count;
}

// Main route: shows current time in Moscow
app.get('/', (req, res) => {
  // Get current time in Moscow using the built-in Intl API
  const options = { timeZone: 'Europe/Moscow', hour12: false };
  const moscowTimeString = new Date().toLocaleString('en-US', options);
  const moscowTime = new Date(moscowTimeString);
  // Update Prometheus gauge (convert to seconds)
  currentTimeGauge.set(moscowTime.getTime() / 1000);
  // Format the time for display
  const formattedTime = formatDate(moscowTime);
  // Update visit counter
  updateVisits();
  res.send(`
    <h1>Welcome to my Node.js Web App!</h1>
    <h1>Current Time in Moscow: ${formattedTime} MSK</h1>
  `);
});

// displays the current visit count
app.get('/visits', (req, res) => {
  const count = getVisits();
  res.send(`<h2>Number of visits: ${count}</h2>`);
});

// Expose metrics endpoint for Prometheus
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType);
  res.end(await register.metrics());
});

// Start server on port 3000 (or process.env.PORT if defined)
const PORT = process.env.PORT || 3000;
if (require.main === module) {
  app.listen(PORT, () => {
    console.log(`Node.js app is running at http://localhost:${PORT}`);
  });
}

module.exports = app;

```

### 1.2 Docker Compose Volume Configuration


#### For the Node.js Application (/monitoring/docker-compose.yml)

```yaml
  app_nodejs:
    image: sedoxxx/node-webapp:latest
    container_name: app_nodejs
    ports:
      - "8005:3000"
    volumes:
      - ./node_visits:/app/visits
```

#### For the Python Application (/monitoring/docker-compose.yml)

```yaml
  app_python:
    image: sedoxxx/python-webapp:latest
    container_name: app_python
    ports:
      - "8004:5000"
    volumes:
      - ./python_visits:/app/visits
```

## Step 2: ConfigMap Implementation

### 2.1 Create a Config File

Place a `config.json` file in a `files` directory with your configuration data. For example:

```json
{
    "appName": "Python App Moscow Time",
    "version": "1.0.0",
    "environment": "production",
    "timezone": "Europe/Moscow",
    "features": {
      "timeDisplay": true,
      "apiEndpoints": true,
      "visitsEndpoint": true
    },
    "logging": {
      "level": "info",
      "format": "json",
      "enableConsole": true
    },
    "performance": {
      "caching": true,
      "cacheTTL": 3600
    }
  } 
```

### 2.2 Create a ConfigMap Manifest

create a `configmap.yaml` template that extracts data from `files/config.json`:

```yaml
apiVersion: v1
 kind: ConfigMap
 metadata:
   name: {{ include "python-app.fullname" . }}-config
   labels:
     {{- include "python-app.labels" . | nindent 4 }}
 data:
   config.json: |-
 {{ .Files.Get "files/config.json" | indent 4 }} 
```


### Persistence Configuration

1. Added persistence configuration to `values.yaml` for both apps:

```yaml
persistence:
  enabled: true
  accessMode: ReadWriteOnce
  size: 1Gi
```

2. Created a PVC template for storing visits data for both apps:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ include "python-app.fullname" . }}-visits-pvc
spec:
  accessModes:
    - {{ .Values.persistence.accessMode | quote }}
  resources:
    requests:
      storage: {{ .Values.persistence.size | quote }}
```

3. Volumes and VolumeMounts Configuration

Updated `values.yaml` with volume configurations:

```yaml
# Additional volumes on the output Deployment definition.
volumes:
- name: config-volume
  configMap:
    name: python-app-config
    items:
    - key: config.json
      path: config.json
- name: visits-volume
  emptyDir: {}

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
- name: config-volume
  mountPath: "/app/config"
  readOnly: true
- name: visits-volume
  mountPath: "/app/visits"
```

5. Chart Installation and Verification

```bash
# Install/upgrade the Helm chart
helm upgrade --install python-app ./k8s/python-app

# Get the list of pods
kubectl get po
NAME                                    READY   STATUS     RESTARTS   AGE
helm-node-app-65bc8f65cc-25b4q          1/1     Running    0          24h
helm-python-app-5fd885fb6f-xqqg2        1/1     Running    0          24h
python-app-84ft569cff-gyu2f             2/2     Running    0          32s


# Check the ConfigMap inside the pod
kubectl exec python-app-84ft569cff-gyu2f -- cat /app/config/config.json
{
    "appName": "Python App Moscow Time",
    "version": "1.0.0",
    "environment": "production",
    "timezone": "Europe/Moscow",
    "features": {
      "timeDisplay": true,
      "apiEndpoints": true,
      "visitsEndpoint": true
    },
    "logging": {
      "level": "info",
      "format": "json",
      "enableConsole": true
    },
    "performance": {
      "caching": true,
      "cacheTTL": 3600
    }
  }
```