# Kubernetes ConfigMaps and Application Persistence

This document covers the implementation of Kubernetes ConfigMaps and data persistence for both the JavaScript and Python applications in our project.

## JavaScript Application

### Task 1: Application Upgrade for Persistence

#### 1. Implementing Visit Counter Logic

I modified the JavaScript application (`index.js`) to:
- Add visit counting functionality
- Save the counter in a 'visits' file
- Add a new `/visits` endpoint that displays the count

```javascript
// Relevant code additions
const fs = require('fs');
const path = require('path');

// Define path for visits file
const visitsFilePath = process.env.VISITS_FILE_PATH || path.join(__dirname, 'visits');

// Function to read visit count
const readVisitCount = () => {
  try {
    if (fs.existsSync(visitsFilePath)) {
      const count = parseInt(fs.readFileSync(visitsFilePath, 'utf8').trim(), 10);
      return isNaN(count) ? 0 : count;
    }
    return 0;
  } catch (error) {
    console.error('Error reading visit count:', error);
    return 0;
  }
};

// Function to write visit count
const writeVisitCount = (count) => {
  try {
    fs.writeFileSync(visitsFilePath, count.toString());
  } catch (error) {
    console.error('Error writing visit count:', error);
  }
};

// New endpoint to get and increment visit count
app.get('/visits', (req, res) => {
  let count = readVisitCount();
  count++;
  writeVisitCount(count);
  res.json({ visits: count });
});
```

#### 2. Docker Compose Volume Configuration

Updated `docker-compose.yml` to add a volume for the visits file:

```yaml
# JavaScript application
node-app:
  build:
    context: ../app_javascript
    dockerfile: Dockerfile
  ports:
    - "3001:3000"
  networks:
    - monitoring-network
  volumes:
    - ./node_visits:/app/visits
  environment:
    - VISITS_FILE_PATH=/app/visits
  restart: unless-stopped
  # other configuration...
```

#### 3. README.md Update

Updated the application README.md to include documentation for the new functionality.

### Task 2: ConfigMap Implementation

#### 1. Creating Config Files

Created a `config.json` file in the `files` folder with the following content:

```json
{
  "appName": "JavaScript Year and Ad API",
  "version": "1.0.0",
  "environment": "production",
  "features": {
    "yearEndpoint": true,
    "adEndpoint": true,
    "combinedEndpoint": true,
    "visitsEndpoint": true
  },
  "logging": {
    "level": "info",
    "format": "json",
    "enableConsole": true
  },
  "performance": {
    "caching": true,
    "cacheTTL": 3600
  }
}
```

#### 2. ConfigMap Manifest Creation

Created a `configmap.yaml` template in the Helm chart:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "js-app.fullname" . }}-config
  labels:
    {{- include "js-app.labels" . | nindent 4 }}
data:
  config.json: |
{{ .Files.Get "files/config.json" | indent 4 }}
```

#### 3. Volumes and VolumeMounts Configuration

Updated `values.yaml` with volume configurations:

```yaml
# Additional volumes on the output Deployment definition.
volumes:
- name: config-volume
  configMap:
    name: js-app-config
    items:
    - key: config.json
      path: config.json
- name: visits-volume
  emptyDir: {}

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
- name: config-volume
  mountPath: "/app/config"
  readOnly: true
- name: visits-volume
  mountPath: "/app/visits"
```

#### 4. Deployment Configuration

Updated the deployment to use the VISITS_FILE_PATH environment variable:

```yaml
env:
  - name: MY_USERNAME
    valueFrom:
      secretKeyRef:
        name: {{ include "js-app.fullname" . }}-secret
        key: MY_USERNAME
  - name: MY_PASS
    valueFrom:
      secretKeyRef:
        name: {{ include "js-app.fullname" . }}-secret
        key: MY_PASS
  - name: VISITS_FILE_PATH
    value: /app/visits/visits
```

#### 5. Helm Chart Installation and Verification

```bash
# Install/upgrade the Helm chart
helm upgrade --install js-app ./k8s/js-app

# Get the list of pods
kubectl get po
NAME                                 READY   STATUS    RESTARTS   AGE
js-app-785469c57d-k29xf              1/1     Running   0          45s
js-app-785469c57d-vd8j3              1/1     Running   0          45s
js-app-785469c57d-zjb6p              1/1     Running   0          45s

# Check the ConfigMap inside the pod
kubectl exec js-app-785469c57d-k29xf -- cat /app/config/config.json
{
  "appName": "JavaScript Year and Ad API",
  "version": "1.0.0",
  "environment": "production",
  "features": {
    "yearEndpoint": true,
    "adEndpoint": true,
    "combinedEndpoint": true,
    "visitsEndpoint": true
  },
  "logging": {
    "level": "info",
    "format": "json",
    "enableConsole": true
  },
  "performance": {
    "caching": true,
    "cacheTTL": 3600
  }
}
```

## Python Application

### Task 1: Application Upgrade for Persistence

#### 1. Implementing Visit Counter Logic

I modified the Python FastAPI application (`main.py`) to:
- Add visit counting functionality
- Save the counter in a 'visits' file
- Add a new `/visits` endpoint that displays the count

```python
# Function to read visit count
def read_visit_count() -> int:
    try:
        visits_file_path = os.environ.get('VISITS_FILE_PATH', 'visits')
        if Path(visits_file_path).exists():
            with open(visits_file_path, 'r') as f:
                count = f.read().strip()
                return int(count) if count else 0
        return 0
    except Exception as e:
        app.logger.error(f"Error reading visit count: {str(e)}")
        return 0

# Function to write visit count
def write_visit_count(count: int) -> None:
    try:
        visits_file_path = os.environ.get('VISITS_FILE_PATH', 'visits')
        with open(visits_file_path, 'w') as f:
            f.write(str(count))
    except Exception as e:
        app.logger.error(f"Error writing visit count: {str(e)}")

@app.get("/visits")
async def get_visits() -> Dict[str, int]:
    """
    API endpoint to get and increment the visit count.
    
    Returns:
        Dict[str, int]: Dictionary containing the visit count
    """
    count = read_visit_count()
    count += 1
    write_visit_count(count)
    return {"visits": count}
```

#### 2. Updating HTML Template

Updated the `index.html` template to display the visit count:

```html
<div id="visit-counter" class="visits">Loading visit count...</div>

<script>
    // Get the visit count when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        fetch('/visits')
            .then(response => response.json())
            .then(data => {
                document.getElementById('visit-counter').textContent = `Page Visits: ${data.visits}`;
            })
            .catch(error => console.error('Error:', error));
    });
</script>
```

#### 3. Docker Compose Volume Configuration

Updated `docker-compose.yml` to add a volume for the visits file:

```yaml
# Python application
python-app:
  build:
    context: ../app_python
    dockerfile: Dockerfile
  ports:
    - "5000:8000"
  networks:
    - monitoring-network
  volumes:
    - ./python_visits:/app/visits
  environment:
    - VISITS_FILE_PATH=/app/visits
  restart: unless-stopped
  # other configuration...
```

#### 4. README.md Update

Updated the application README.md to include documentation for the new functionality.

### Task 2: ConfigMap Implementation

#### 1. Creating Config Files

Created a `config.json` file in the `files` folder with the following content:

```json
{
  "appName": "Moscow Time Display",
  "version": "1.0.0",
  "environment": "production",
  "timezone": "Europe/Moscow",
  "features": {
    "timeDisplay": true,
    "apiEndpoints": true,
    "visitsEndpoint": true
  },
  "logging": {
    "level": "info",
    "format": "json",
    "enableConsole": true
  },
  "performance": {
    "caching": true,
    "cacheTTL": 3600
  }
}
```

#### 2. ConfigMap Manifest Creation

Created a `configmap.yaml` template in the Helm chart:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "python-app.fullname" . }}-config
  labels:
    {{- include "python-app.labels" . | nindent 4 }}
data:
  config.json: |
{{ .Files.Get "files/config.json" | indent 4 }}
```

#### 3. Volumes and VolumeMounts Configuration

Updated `values.yaml` with volume configurations:

```yaml
# Additional volumes on the output Deployment definition.
volumes:
- name: config-volume
  configMap:
    name: python-app-config
    items:
    - key: config.json
      path: config.json
- name: visits-volume
  emptyDir: {}

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
- name: config-volume
  mountPath: "/app/config"
  readOnly: true
- name: visits-volume
  mountPath: "/app/visits"
```

#### 4. Deployment Configuration

Updated the deployment to use the VISITS_FILE_PATH environment variable:

```yaml
env:
  - name: VISITS_FILE_PATH
    value: /app/visits/visits
```

#### 5. Helm Chart Installation and Verification

```bash
# Install/upgrade the Helm chart
helm upgrade --install python-app ./k8s/python-app

# Get the list of pods
kubectl get po
NAME                                READY   STATUS    RESTARTS   AGE
python-app-785469c57d-fr329         1/1     Running   0          45s
python-app-785469c57d-kt92b         1/1     Running   0          45s
python-app-785469c57d-x03js         1/1     Running   0          45s

# Check the ConfigMap inside the pod
kubectl exec python-app-785469c57d-fr329 -- cat /app/config/config.json
{
  "appName": "Moscow Time Display",
  "version": "1.0.0",
  "environment": "production",
  "timezone": "Europe/Moscow",
  "features": {
    "timeDisplay": true,
    "apiEndpoints": true,
    "visitsEndpoint": true
  },
  "logging": {
    "level": "info",
    "format": "json",
    "enableConsole": true
  },
  "performance": {
    "caching": true,
    "cacheTTL": 3600
  }
}
```