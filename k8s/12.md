# Lab 12: Kubernetes ConfigMaps

## ConfigMap Implementation

This document provides documentation for the implementation of ConfigMaps in our Kubernetes deployment.

### 1. Created ConfigMap from config.json

I created a `files` folder with a `config.json` file containing application configuration data. Then I implemented a ConfigMap in the Helm chart that extracts data from this file using `.Files.Get`.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "python-app.fullname" . }}-config
  labels:
    {{- include "python-app.labels" . | nindent 4 }}
data:
  config.json: |
    {{- .Files.Get "files/config.json" | nindent 4 }}
```

### 2. Updated Deployment with Volumes and VolumeMounts

I updated the `deployment.yaml` to include the necessary `Volumes` and `VolumeMounts` to make the ConfigMap available to the application:

```yaml
# Volume mount in container spec
volumesMounts:
  - name: config-volume
    mountPath: /app/config.json
    subPath: config.json

# Volume definition in pod spec
volumes:
  - name: config-volume
    configMap:
      name: {{ include "python-app.fullname" . }}-config
```

### 3. Verification Commands

After deploying the Helm chart, I'll verify the ConfigMap implementation with the following commands:

```bash
kubectl get po

NAME                                    READY   STATUS    RESTARTS       AGE
python-app-559c7b7c68-m56xq             1/1     Running   0              65s
vault-0                                 0/1     Running   1 (12m ago)    3d22h
vault-agent-injector-669f58d9b5-pl2q9   1/1     Running   1 (3d4h ago)   3d22h

kubectl exec python-app-559c7b7c68-m56xq -- cat /app/config.json

{
  "app": {
    "name": "python-app",
    "version": "1.0.0",
    "environment": "development"
  },
  "features": {
    "logging": true,
    "metrics": true,
    "persistence": true
  },
  "settings": {
    "timezone": "Europe/Moscow",
    "maxVisits": 10000,
    "refreshInterval": 60
  }
}
```

### 4. Benefits of Using ConfigMaps

- Separation of configuration from application code
- Configuration can be updated without rebuilding container images
- Configuration can be managed using Kubernetes tools and processes
- Different environments can use different configurations with the same image
