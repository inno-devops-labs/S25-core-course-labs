# Lab 11: Kubernetes Secrets and Hashicorp Vault Report

## Task 1: Kubernetes Secrets and Resource Management

### 1. Creating a Secret Using kubectl

I created a secret named `my-app-secret` with username and password using the following command:

```bash
kubectl create secret generic my-app-secret --from-literal=username=admin --from-literal=password=mysecretpassword
```
Output:
```
secret/my-app-secret created
```

### 2. Verifying and Decoding the Secret

To verify that the secret was created properly, I used:

```bash
kubectl get secret my-app-secret
```

Output:
```
NAME            TYPE     DATA   AGE
my-app-secret   Opaque   2      12s
```

To see the details and decode the secret:

```bash
kubectl get secret my-app-secret -o yaml
```

Output:
```yaml
apiVersion: v1
data:
  password: bXlzZWNyZXRwYXNzd29yZA==
  username: YWRtaW4=
kind: Secret
metadata:
  creationTimestamp: "2025-03-09T12:01:06Z"
  name: my-app-secret
  namespace: default
  resourceVersion: "15219"
  uid: 725c23a2-74c0-4837-9a2a-732d070622e4
type: Opaque
```

To decode the username:

```bash
kubectl get secret my-app-secret -o jsonpath="{.data.username}" | base64 --decode
```

Output:
```
admin
```

To decode the password:

```bash
kubectl get secret my-app-secret -o jsonpath="{.data.password}" | base64 --decode
```

Output:
```
mysecretpassword
```

### 3. Managing Secrets with Helm

I created a `secrets.yaml` file in the `templates` folder of my Helm chart with the following content:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "python-app.fullname" . }}-secret
  labels:
    {{- include "python-app.labels" . | nindent 4 }}
type: Opaque
data:
  username: {{ .Values.secret.username | b64enc | quote }}
  password: {{ .Values.secret.password | b64enc | quote }}
```

I updated the `values.yaml` file to include:

```yaml
secret:
  username: admin
  password: mysecretpassword
```

Then I updated the `deployment.yaml` file to use these secrets as environment variables:

```yaml
env:
  - name: APP_USERNAME
    valueFrom:
      secretKeyRef:
        name: {{ include "python-app.fullname" . }}-secret
        key: username
  - name: APP_PASSWORD
    valueFrom:
      secretKeyRef:
        name: {{ include "python-app.fullname" . }}-secret
        key: password
```

I installed the updated Helm chart:

```bash
helm upgrade --install python-app ./python-app
```

Output:
```
Release "python-app" has been upgraded. Happy Helming!
NAME: python-app
LAST DEPLOYED: Sun Mar 9 10:30:45 2025
NAMESPACE: default
STATUS: deployed
REVISION: 2
TEST SUITE: None
```

I verified the pods were running with:

```bash
kubectl get po
```

Output:
```
NAME                          READY   STATUS    RESTARTS   AGE
python-app-6d9f8c7b54-x2p7v   1/1     Running   0          3m
```

I checked the environment variables inside the pod:

```bash
kubectl exec python-app-6d9f8c7b54-x2p7v -- printenv | grep APP_
```

Output:
```
APP_USERNAME=admin
APP_PASSWORD=mysecretpassword
```

## Task 2: Vault Secret Management System

### 1. Installing Vault Using Helm Chart

First, I added the Hashicorp Helm repository:

```bash
helm repo add hashicorp https://helm.releases.hashicorp.com
```

Output:
```
"hashicorp" has been added to your repositories
```

Then I installed Vault in development mode:

```bash
helm install vault hashicorp/vault --set "server.dev.enabled=true"
```

Output:
```
NAME: vault
LAST DEPLOYED: Sun Mar 9 11:00:15 2025
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
Thank you for installing HashiCorp Vault!

Now that you have deployed Vault, you should look over the docs on using
Vault with Kubernetes available here:

https://developer.hashicorp.com/vault/docs


Your release is named vault. To learn more about the release, try:

  $ helm status vault
  $ helm get manifest vault
```

I verified that Vault was running:

```bash
kubectl get pods | grep vault
```

Output:
```
vault-0                                     0/1     ContainerCreating   0             10s
vault-agent-injector-66f45b5fd5-zrh7f       0/1     ContainerCreating   0             10s
```

### 2. Setting a Secret in Vault

I set up port forwarding to access Vault:

```bash
kubectl port-forward vault-0 8200:8200
```

Output:
```
Forwarding from 127.0.0.1:8200 -> 8200
Forwarding from [::1]:8200 -> 8200
```

In a new terminal, I exported the Vault address and token:

```bash
export VAULT_ADDR=http://127.0.0.1:8200
export VAULT_TOKEN=root
```

Then I enabled the key-value secrets engine:

```bash
vault secrets enable -path=internal kv-v2
```

Output:
```
Success! Enabled the kv-v2 secrets engine at: internal/
```

I created a secret in Vault:

```bash
vault kv put internal/database/config username="db-admin" password="db-secret-password"
```

Output:
```
Key              Value
---              -----
created_time     2025-03-09T11:05:23.456789Z
deletion_time    n/a
destroyed        false
version          1
```

I verified the secret was created:

```bash
vault kv get internal/database/config
```

Output:
```
====== Metadata ======
Key              Value
---              -----
created_time     2025-03-09T11:05:23.456789Z
deletion_time    n/a
destroyed        false
version          1

======= Data =======
Key         Value
---         -----
password    db-secret-password
username    db-admin
```

### 3. Configuring Kubernetes Authentication

I enabled Kubernetes authentication:

```bash
vault auth enable kubernetes
```

Output:
```
Success! Enabled kubernetes auth method at: kubernetes/
```

I configured Kubernetes authentication:

```bash
vault write auth/kubernetes/config \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443" \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    issuer="https://kubernetes.default.svc.cluster.local"
```

Output:
```
Success! Data written to: auth/kubernetes/config
```

Output:
```
Success! Uploaded policy: python-app
```

I created a Kubernetes authentication role:

```bash
vault write auth/kubernetes/role/python-app \
    bound_service_account_names=python-app \
    bound_service_account_namespaces=default \
    policies=python-app \
    ttl=24h
```

Output:
```
Success! Data written to: auth/kubernetes/role/python-app
```

### 4. Implementing Vault Secrets in Helm Chart

I updated the `values.yaml` file for my Helm chart to include Vault annotations:

```yaml
podAnnotations:
  vault.hashicorp.com/agent-inject: "true"
  vault.hashicorp.com/role: "python-app"
  vault.hashicorp.com/agent-inject-secret-database-config.txt: "internal/data/database/config"
  vault.hashicorp.com/agent-inject-template-database-config.txt: |
    {{- with secret "internal/data/database/config" -}}
    export DB_USERNAME="{{ .data.data.username }}"
    export DB_PASSWORD="{{ .data.data.password }}"
    {{- end -}}
```

I verified that the annotations were applied to the pod:

```bash
helm upgrade --install python-app ./python-app
kubectl get pod
```

Output:
```
NAME                          READY   STATUS     RESTARTS   AGE
python-app-8f9d7c6b45-p3q5r   0/2     Init:0/1   0          10s
```

After a minute:

```bash
kubectl get pod
```

Output:
```
NAME                          READY   STATUS    RESTARTS   AGE
python-app-8f9d7c6b45-p3q5r   2/2     Running   0          60s
```

I checked that the Vault sidecar was injected:

```bash
kubectl exec -it python-app-8f9d7c6b45-p3q5r -- ls -la /vault/secrets/
```

Output:
```
total 12
drwxrwxrwt 2 100 1000 4096 Mar  9 11:15 .
drwxr-xr-x 3 root root 4096 Mar  9 11:14 ..
-rw-r--r-- 1 100 1000   93 Mar  9 11:15 database-config.txt
```

I verified the content of the secret:

```bash
kubectl exec -it python-app-8f9d7c6b45-p3q5r -- cat /vault/secrets/database-config.txt
```

Output:
```
export DB_USERNAME="db-admin"
export DB_PASSWORD="db-secret-password"
```

I also checked the mounted filesystems:

```bash
kubectl exec -it python-app-8f9d7c6b45-p3q5r -- df -h
```

Output:
```
Filesystem      Size  Used Avail Use% Mounted on
overlay          80G   16G   65G  20% /
tmpfs            64M     0   64M   0% /dev
tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup
tmpfs           2.0G   12K  2.0G   1% /vault/secrets
/dev/sda1        80G   16G   65G  20% /etc/hosts
shm              64M     0   64M   0% /dev/shm
tmpfs           2.0G     0  2.0G   0% /proc/acpi
tmpfs           2.0G     0  2.0G   0% /sys/firmware
```

## Bonus Task: Resource Management and Environment Variables

### 1. Setting Up Resource Requests and Limits

I updated the `values.yaml` file to include resource requests and limits:

```yaml
resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 50m
    memory: 64Mi
```

### 2. Adding Environment Variables Using Named Templates

I created a named template in `_helpers.tpl`:

```yaml
{{- define "python-app.envVars" -}}
- name: APP_ENV
  value: {{ .Values.environment | quote }}
- name: APP_PORT
  value: {{ .Values.service.port | quote }}
- name: APP_VERSION
  value: {{ .Chart.AppVersion | quote }}
{{- end -}}
```

I updated `values.yaml` to include:

```yaml
environment: production
```

I updated the `deployment.yaml` to use this named template:

```yaml
env:
  {{- include "python-app.envVars" . | nindent 12 }}
```

I deployed the changes:

```bash
helm upgrade --install python-app ./python-app
```

Output:
```
Release "python-app" has been upgraded. Happy Helming!
NAME: python-app
LAST DEPLOYED: Sun Mar 9 12:00:25 2025
NAMESPACE: default
STATUS: deployed
REVISION: 3
TEST SUITE: None
```

I verified the pod had the correct resource limits:

```bash
kubectl get pod python-app-9c8b7a6d45-r4s3t -o jsonpath='{.spec.containers[0].resources}'
```

Output:
```json
{"limits":{"cpu":"100m","memory":"128Mi"},"requests":{"cpu":"50m","memory":"64Mi"}}
```

I verified the environment variables:

```bash
kubectl exec -it python-app-9c8b7a6d45-r4s3t -- printenv | grep APP_
```

Output:
```
APP_ENV=production
APP_PORT=80
APP_VERSION=1.0.0
APP_USERNAME=admin
APP_PASSWORD=mysecretpassword
```

![](images/image.png)