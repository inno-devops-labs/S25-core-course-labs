# Lab 11: Kubernetes Secrets and HashiCorp Vault

## **Author:** Mohammad Jaafar - CBS-01

---

## **1. Task 1: Kubernetes Secrets and Resource Management**

### **1.1 Creating a Secret Using `kubectl`**

To securely store environment variables, I created a Kubernetes **Secret** using `kubectl`:

### Command

```bash
kubectl create secret generic my-secret --from-literal=MY_USER=admin --from-literal=MY_PASS=SuperSecretPassword123

```

### Output

```sh
secret/my-secret created

```

![image.png](./ScreenshotsLab11/image.png)

‚úî This confirms that the secret was successfully created.

---

### **1.2 Verify and Decode the Secret**

After creating the secret, I **verified** its existence:

 Command:

```bash
kubectl get secrets

```

### **Output:**

![image.png](./ScreenshotsLab11/image%201.png)

üìå **The secret `my-secret` contains 2 key-value pairs (`MY_USER` and `MY_PASS`).**

### **Retrieve and Decode the Secret**

To confirm the stored values:

```bash
kubectl get secret my-secret -o jsonpath="{.data.MY_USER}" | base64 --decode && echo
kubectl get secret my-secret -o jsonpath="{.data.MY_PASS}" | base64 --decode && echo

```

 Output

```sh
admin
SuperSecretPassword123

```

![image.png](./ScreenshotsLab11/image%202.png)

‚úî **This confirms that the secret is correctly stored and retrievable.**

---

### **1.3 Managing Secrets with Helm**

Instead of using `kubectl`, I managed secrets with **Helm**.

üìç **Created `secrets.yaml` in `templates/`**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  MY_USER: {{ .Values.secrets.user | b64enc | quote }}
  MY_PASS: {{ .Values.secrets.password | b64enc | quote }}

```

![image.png](./ScreenshotsLab11/image%203.png)

üìç **Updated `values.yaml`**

```yaml
secrets:
  user: "admin"
  password: "SuperSecretPassword123"
api:
  url: "http://localhost:5000"

```

![image.png](./ScreenshotsLab11/image%204.png)

üìç **Updated `deployment.yaml` to use secrets and modified `_helpers.tpl`**

```yaml
env:
  - name: MY_USER
    valueFrom:
      secretKeyRef:
        name: my-secret
        key: MY_USER
  - name: MY_PASS
    valueFrom:
      secretKeyRef:
        name: my-secret
        key: MY_PASS

```

![image.png](./ScreenshotsLab11/image%205.png)

![image.png](./ScreenshotsLab11/image%206.png)

‚úî **This allows my application to securely read secrets as environment variables.**

---

### **1.4 Deploying the Helm Chart with Secrets**

After defining secrets in Helm, I deployed the updated Helm chart:

### **Command:**

```bash
helm upgrade --install my-python-app ./k8s/python-app

```

![image.png](./ScreenshotsLab11/image%207.png)

‚úî **This applies the new deployment, including secrets.**

---

### **1.5 Verify Secret Inside the Pod**

To check if the environment variables were injected correctly:

### **Find the Running Pod**

```bash
kubectl get pods

```

### Output

![image.png](./ScreenshotsLab11/image%208.png)

‚úî **I used this pod name in the next step.**

### **Check the Secret Inside the Pod**

```bash
kubectl exec -it my-python-app-795fb4444b-td9kq -- printenv | grep MY_
```

### Output

![image.png](./ScreenshotsLab11/image%209.png)

üìå **This confirms the secret is injected into the container.**

---

## **Task 2: Vault Secret Management System**

## **1. Install Vault Using Helm**

To securely manage secrets in Kubernetes, I installed **HashiCorp Vault** using the Helm chart.

```bash
helm repo add hashicorp https://helm.releases.hashicorp.com
helm repo update
helm install vault hashicorp/vault

```

![image.png](./ScreenshotsLab11/image%2010.png)

### **Verify Vault Installation**

```bash
kubectl get pods

```

![image.png](./ScreenshotsLab11/image%2011.png)

### **2. Configure Vault for Kubernetes Authentication**

---

### **Check if Kubernetes Authentication Is Enabled**

```bash
vault auth list

```

### **Output:**

```sh
Path                 Type        Accessor
----                 ----        --------
auth/kubernetes/     kubernetes  auth_kubernetes_xxxx

```

![image.png](./ScreenshotsLab11/image%2012.png)

‚úî **Vault authentication with Kubernetes is enabled.** ‚úÖ

---

### **Check Vault‚Äôs Connection to Kubernetes**

```bash
vault read auth/kubernetes/config

```

### **Output:**

![image.png](./ScreenshotsLab11/image%2013.png)

‚úî **Vault is correctly configured to authenticate with Kubernetes.** ‚úÖ

---

## **3. Configure the Vault Role for `my-python-app`**

### **Create a Vault Policy for `my-python-app`**

```bash
vault policy write my-python-app-policy - <<EOF
path "internal/data/myapp" {
    capabilities = ["read"]
}
EOF

```

![image.png](./ScreenshotsLab11/image%2014.png)

‚úî **Vault policy successfully created.** ‚úÖ

### **Create a Vault Role for the App**

```bash
vault write auth/kubernetes/role/my-python-app \
    bound_service_account_names=my-python-app \
    bound_service_account_namespaces=default \
    policies=my-python-app-policy \
    ttl=1h

```

### **Output:**

![image.png](./ScreenshotsLab11/image%2015.png)

‚úî **Vault role successfully created for the app.** ‚úÖ

---

## **4. Verify That Vault Secrets Are Injected**

### **Check Injected Secrets as Environment Variables**

```bash
kubectl exec -it my-python-app-769f8977fc-gwt7s -- printenv | grep VAULT_

```

### **Output:**

![image.png](./ScreenshotsLab11/image%2016.png)

‚úî **Vault secrets are correctly injected as environment variables.** ‚úÖ

---

### **Check Injected Secrets as Files**

```bash
kubectl exec -it my-python-app-769f8977fc-gwt7s -- ls /vault/secrets/

```

### **Output:**

```sh
myapp

```

![image.png](./ScreenshotsLab11/image%2017.png)

‚úî **Vault successfully injected the secret as a file.** ‚úÖ

### **Read the Secret File**

```bash
kubectl exec -it my-python-app-769f8977fc-gwt7s -- cat /vault/secrets/myapp

```

### **Output:**

```sh
{"username":"admin","password":"SuperSecure123"}

```

![image.png](./ScreenshotsLab11/image%2018.png)

‚úî **The secret was successfully retrieved from Vault.** ‚úÖ

---

## **5. Verify Pod Deployment**

```bash
kubectl get po

```

### **Output:**

![image.png](./ScreenshotsLab11/image%2019.png)

‚úî **Application successfully redeployed with Vault secrets.** ‚úÖ

---

## **6. Verify System Disk Usage**

```bash
kubectl exec -it my-python-app-769f8977fc-gwt7s -- df -h

```

### **Output:**

![image.png](./ScreenshotsLab11/image%2020.png)

‚úî **Vault secrets are correctly mounted in `/vault/secrets/`.** ‚úÖ

**Why check disk usage?**
This confirms that the Vault secrets were successfully mounted in the container.

---

## **Bonus Task: Resource Management and Environment Variables**

In this section, I configured **resource limits**, **requests**, and **environment variables** for both Helm charts (`python-app` and `node-app`). I also verified that Kubernetes secrets and Vault secrets are properly injected.

---

## **1Ô∏è‚É£ Configuring Resource Requests and Limits**

To ensure efficient resource usage, I updated `values.yaml` for both applications:

üìç **File: `k8s/python-app/values.yaml`**

```yaml
resources:
  requests:
    memory: "128Mi"
    cpu: "250m"
  limits:
    memory: "256Mi"
    cpu: "500m"

```

üìç **File: `k8s/node-app/values.yaml`**

```yaml
resources:
  requests:
    memory: "128Mi"
    cpu: "250m"
  limits:
    memory: "256Mi"
    cpu: "500m"

```

### **Verifying Resource Limits**

After applying the Helm upgrade, I verified the resource allocations:

```bash
kubectl get pod my-python-app-6bc58658c4-lnth6 -o=jsonpath="{.spec.containers[*].resources}"

```

![image.png](./ScreenshotsLab11/image%2021.png)

‚úî **Confirmed resource limits and requests are applied correctly!** ‚úÖ

---

## **2Ô∏è‚É£ Configuring Environment Variables**

To ensure environment variables are dynamically injected, I used **Helm Named Templates**.

üìç **File: `k8s/python-app/templates/_helpers.tpl`**

```yaml
{{- define "custom.env" -}}
  - name: APP_ENV
    value: "production"
  - name: API_URL
    value: "http://localhost:5000"
  - name: DATABASE_HOST
    valueFrom:
        secretKeyRef:
          name: my-secret
          key: DATABASE_HOST
  - name: DATABASE_PASSWORD
    valueFrom:
        secretKeyRef:
          name: my-secret
          key: DATABASE_PASSWORD
{{- end -}}

```

![image.png](./ScreenshotsLab11/image%2022.png)

üìç **File: `k8s/python-app/templates/deployment.yaml`**

```yaml
env:
  {{- include "custom.env" . | nindent 8 }}

```

üìç **File: `k8s/node-app/templates/deployment.yaml`**

```yaml
env:
  - name: NODE_ENV
    value: "production"
  - name: SERVICE_PORT
    value: "8080"

```

###

---

## **3Ô∏è‚É£ Verifying Vault Secrets Injection**

I confirmed that Vault secrets were injected into the pod as both **environment variables** and **files**.

üìç **Verify secrets injected into environment variables:**

```bash
kubectl exec -it my-python-app-5855ddd974-9lmd8 -- printenv | grep MY_

```

‚úî**Output:**

```sh
MY_USER=admin
MY_PASS=SuperSecurePassword

```

![image.png](./ScreenshotsLab11/image%2023.png)

üìç **Verify secrets injected into files:**

```bash
kubectl exec -it my-python-app-5855ddd974-9lmd8 -- cat /vault/secrets/myapp

```

‚úî**Output:**

```sh
export MY_USER="admin"
export MY_PASS="SuperSecure123"

```

![image.png](./ScreenshotsLab11/image%2024.png)

---

## **4Ô∏è‚É£ Final Verification of Resource Usage**

I checked the actual memory and CPU usage of my pods:

```bash
kubectl top pod node-app-59dd9b9cd-8dbb6

```

![image.png](./ScreenshotsLab11/image%2025.png)

‚úî **Pods are running within the expected resource limits!** ‚úÖ

---
