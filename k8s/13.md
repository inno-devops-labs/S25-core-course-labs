# Lab 13: ArgoCD for GitOps Deployment - Documentation

## Overview

This document provides documentation for the implementation of ArgoCD for GitOps deployment in our Kubernetes environment. The implementation follows the tasks outlined in lab13.md.

## Task 1: Deploy and Configure ArgoCD

### 1. Install ArgoCD via Helm

To install ArgoCD, run the following commands:

```bash
# Add the ArgoCD Helm repository
helm repo add argo https://argoproj.github.io/argo-helm

# Install ArgoCD
helm install argo argo/argo-cd --namespace argocd --create-namespace

# Verify installation
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=90s
```

### 2. Install ArgoCD CLI

Install the ArgoCD CLI tool:

```bash
# For macOS (Homebrew):
brew install argocd

# Verify CLI installation
argocd version
```

### 3. Access the ArgoCD UI

To access the ArgoCD UI, run the following commands:

```bash
# Forward the ArgoCD server port
kubectl port-forward svc/argocd-server -n argocd 8080:443 &

# Retrieve the password
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode

# Log in via CLI
argocd login localhost:8080 --insecure
argocd account login
```

### 4. Configure Python App Sync

I've created the ArgoCD application manifest for the Python app in `k8s/ArgoCD/argocd-python-app.yaml`. To apply it, run:

```bash
kubectl apply -f k8s/ArgoCD/argocd-python-app.yaml

# Verify sync
argocd app sync python-app
argocd app status python-app
```

## Task 2: Multi-Environment Deployment & Auto-Sync

### 1. Set Up Multi-Environment Configurations

I've created environment-specific values files for the Python app:
- `k8s/python-app/values-dev.yaml` - Development environment configuration
- `k8s/python-app/values-prod.yaml` - Production environment configuration

### 2. Create Namespaces

```bash
kubectl create namespace dev
kubectl create namespace prod
```

### 3. Deploy Multi-Environment via ArgoCD

I've created ArgoCD application manifests for both environments:
- `k8s/ArgoCD/argocd-python-dev.yaml` - Development environment
- `k8s/ArgoCD/argocd-python-prod.yaml` - Production environment

To apply them, run:

```bash
kubectl apply -f k8s/ArgoCD/argocd-python-dev.yaml
kubectl apply -f k8s/ArgoCD/argocd-python-prod.yaml

# Verify sync
argocd app sync python-app-dev
argocd app sync python-app-prod
argocd app status python-app-dev
argocd app status python-app-prod
```

### 4. Enable Auto-Sync

Auto-sync is already enabled in the application manifests with the following configuration:

```yaml
syncPolicy:
  automated:
    selfHeal: true
    prune: true
```

### 5. Self-Heal Testing

#### Test 1: Manual Override of Replica Count

```bash
# Modify the deployment's replica count manually
kubectl patch deployment python-app-prod -n prod --patch '{"spec":{"replicas": 3}}'

# Observe ArgoCD auto-revert the change
argocd app sync python-app-prod
argocd app status python-app-prod
```

#### Test 2: Delete a Pod (Replica)

```bash
# Get pod names
kubectl get pods -n prod

# Delete a pod in the prod namespace
kubectl delete pod -n prod -l app.kubernetes.io/name=python-app-prod

# Verify Kubernetes recreates the pod
kubectl get pods -n prod -w

# Confirm ArgoCD shows no drift
argocd app diff python-app-prod
```

## Bonus Task: Sync Your Bonus App with ArgoCD

I've created the ArgoCD application manifest for the Node.js app in `k8s/ArgoCD/argocd-nodejs-app.yaml`. To apply it, run:

```bash
kubectl apply -f k8s/ArgoCD/argocd-nodejs-app.yaml

# Verify sync
argocd app sync nodejs-app
argocd app status nodejs-app
```

## Explanation of ArgoCD Behavior

### Configuration Drift vs. Runtime Events

ArgoCD handles configuration drift and runtime events differently:

1. **Configuration Drift**: When a configuration is manually changed (like scaling replicas with `kubectl patch`), ArgoCD detects this as drift from the desired state defined in Git. With `selfHeal: true`, ArgoCD automatically reverts these changes to match the state in Git.

2. **Runtime Events**: When a pod is deleted, Kubernetes' built-in controllers (not ArgoCD) handle recreation of the pod to maintain the desired replica count. ArgoCD doesn't show drift in this case because the deployment specification (desired state) hasn't changed, only the runtime state temporarily changed and was corrected by Kubernetes.

This distinction is important for understanding GitOps principles: ArgoCD ensures the cluster configuration matches what's in Git, while Kubernetes controllers handle runtime resilience.
