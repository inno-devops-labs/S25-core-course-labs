# AgroCD report

## First test report

### Dashboard 

## Second test report

### Before pod deletion

```sh
tedor49@tedor49:~/S25-core-course-labs/k8s$ kubectl get pods -n prod -w
NAME                                               READY   STATUS    RESTARTS   AGE
python-app-prod-python-msk-time-75b95bcb6d-562hp   1/1     Running   0          116s
python-app-prod-python-msk-time-75b95bcb6d-6qjql   1/1     Running   0          20m
python-app-prod-python-msk-time-75b95bcb6d-8dnxn   1/1     Running   0          20m
```

### After pod deletion

```sh
tedor49@tedor49:~/S25-core-course-labs/k8s$ kubectl get pods -n prod -w
NAME                                               READY   STATUS        RESTARTS   AGE
python-app-prod-python-msk-time-75b95bcb6d-562hp   1/1     Terminating   0          3m7s
python-app-prod-python-msk-time-75b95bcb6d-6qjql   1/1     Terminating   0          21m
python-app-prod-python-msk-time-75b95bcb6d-8dnxn   1/1     Terminating   0          21m
python-app-prod-python-msk-time-75b95bcb6d-9slps   1/1     Running       0          5s
python-app-prod-python-msk-time-75b95bcb6d-mqf5c   1/1     Running       0          5s
python-app-prod-python-msk-time-75b95bcb6d-p4c7m   1/1     Running       0          5s
```
### Dashboard 

## Configuration drift vs. runtime events

ArgoCD syncs the state of the local configuration against the remote configuration wherever it is hosted every so often. If it finds that the local configuration drifted, it updates it to match the remote one, thus ensuring resilience (at least after the sync happens).

On the other hand, runtime events are actually handled by Kubernetes itself, as it was designed to maintain its given state. If the configuration does not match what is in the cluster, Kubernetes creates, deletes, or updates necessary resources so it can try to stay faithful to the configuration provided (which ArgoCD provides, but that is the previous topic).
