# Lab 13: ArgoCD for GitOps Deployment - Deployment Report

## Overview

This report documents the end-to-end process of setting up and configuring ArgoCD for GitOps deployment of our Kubernetes applications. The steps include installing ArgoCD via Helm, configuring ArgoCD to manage our Python application (with multi-environment support), performing self-heal tests. All command outputs, test results, and screenshots are included to verify successful implementation.

---

## Step 1: ArgoCD Installation and Setup

### 1.1 Add ArgoCD Helm Repository and Install ArgoCD

- **Add the repository and update:**
  ```bash
  helm repo add argo https://argoproj.github.io/argo-helm
  helm repo update
  ```
- **Install ArgoCD in its own namespace:**
  ```bash
  helm install argo argo/argo-cd --namespace argocd --create-namespace
  ```
- **Wait for the ArgoCD server to become ready:**
  ```bash
  kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=90s
  ```

### 1.2 Install ArgoCD CLI

- **Installation (example for Debian/Ubuntu):**
  ```bash
  sudo apt-get install -y argocd
  ```
- **Verify installation:**
  ```bash
  argocd version
  ```

### 1.3 Access ArgoCD UI

- **Port-forward the ArgoCD server:**
  ```bash
  kubectl port-forward svc/argocd-server -n argocd 8080:443 &
  ```
- **Retrieve initial admin password:**
  ```bash
  kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode
  ```
- **Log in via CLI:**
  ```bash
  argocd login localhost:8080 --insecure
  argocd account login
  ```
- **Screenshot:**  
  *[Insert screenshot of ArgoCD UI login here]*

---

## Step 2: Configure ArgoCD for the Python Application

### 2.1 Create an ArgoCD Application Manifest

- In the `k8s/ArgoCD` directory, create a file named `argocd-python-app.yaml`:
  ```yaml
  apiVersion: argoproj.io/v1alpha1
  kind: Application
  metadata:
    name: python-app
    namespace: argocd
  spec:
    project: default
    source:
      repoURL: https://github.com/<your-repo>/S25-core-course-labs.git
      targetRevision: lab13
      path: k8s/app-python
      helm:
        valueFiles:
          - values.yaml
    destination:
      server: https://kubernetes.default.svc
      namespace: default
    syncPolicy:
      automated: {}
  ```
- **Apply the manifest:**
  ```bash
  kubectl apply -f ArgoCD/argocd-python-app.yaml
  ```

### 2.2 Sync and Verify

- **Force a sync:**
  ```bash
  argocd app sync python-app
  ```
- **Check the application status:**
  ```bash
  argocd app status python-app
  ```
- **Test Auto-Sync:**  
  Modify a value in `values.yaml` (e.g., change `replicaCount`), push to the repository, and verify that ArgoCD automatically syncs the change:
  ```bash
  argocd app status python-app
  ```
- **Screenshot:**  
  *[Insert screenshot of ArgoCD UI showing sync status]*

---

## Step 3: Multi-Environment Deployment & Self-Healing Tests

### 3.1 Set Up Environment Configurations

- **Create environment-specific values files:**  
  `values-dev.yaml` and `values-prod.yaml` in the Helm chart for the Python app.
- **Create namespaces:**
  ```bash
  kubectl create namespace dev
  kubectl create namespace prod
  ```

### 3.2 Define ArgoCD Applications for Dev and Prod

- **For Development:**  
  Create `argocd-python-dev.yaml`:
  ```yaml
  apiVersion: argoproj.io/v1alpha1
  kind: Application
  metadata:
    name: python-app-dev
    namespace: argocd
  spec:
    project: default
    source:
      repoURL: https://github.com/Sedoxxx/S25-core-course-labs.git
      targetRevision: lab13
      path: k8s/app-python
      helm:
        valueFiles:
          - values-dev.yaml
    destination:
      server: https://kubernetes.default.svc
      namespace: dev
    syncPolicy:
      automated: {}
  ```
- **For Production:**  
  Create `argocd-python-prod.yaml`:
  ```yaml
  apiVersion: argoproj.io/v1alpha1
  kind: Application
  metadata:
    name: python-app-prod
    namespace: argocd
  spec:
    project: default
    source:
      repoURL: https://github.com/Sedoxxx/S25-core-course-labs.git
      targetRevision: lab13
      path: k8s/app-python
      helm:
        valueFiles:
          - values-prod.yaml
    destination:
      server: https://kubernetes.default.svc
      namespace: prod
    syncPolicy:
      automated: {}
  ```
- **Apply both manifests:**
  ```bash
  kubectl apply -f ArgoCD/argocd-python-dev.yaml
  kubectl apply -f ArgoCD/argocd-python-prod.yaml
  ```

### 3.3 Self-Healing Tests in Production

1. **Manual Replica Override:**  
   Patch the production deployment to change replica count:
   ```bash
   kubectl patch deployment python-app-prod -n prod --patch '{"spec":{"replicas": 3}}'
   ```
   Then, trigger a sync and check status:
   ```bash
   argocd app sync python-app-prod
   argocd app status python-app-prod
   ```

2. **Pod Deletion Test:**  
   Delete one of the pods in the production namespace:
   ```bash
   kubectl delete pod -n prod -l app.kubernetes.io/name=python-app
   kubectl get pods -n prod -w
   ```
   Verify that the pod is recreated and check for drift:
   ```bash
   argocd app diff python-app-prod
   ```
- **Screenshot:**  
  *[Insert screenshot of production namespace pods before and after deletion]*

---

## Step 4: Bonus Task â€“ Sync Bonus Application

1. **Configure ArgoCD for the Bonus App:**  
   Create a manifest, for example `argocd-node-app.yaml`, pointing to your bonus application's Helm chart:
   ```yaml
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
    name: node-app
    namespace: argocd
    spec:
    project: default
    source:
        repoURL: https://github.com/Sedoxxx/S25-core-course-labs.git
        targetRevision: lab13
        path: k8s/node-app
        helm:
        valueFiles:
            - values.yaml
    destination:
        server: https://kubernetes.default.svc
        namespace: default
    syncPolicy:
        automated: {}
   ```
2. **Apply and Verify:**
   ```bash
   kubectl apply -f ArgoCD/argocd-node-app.yaml
   kubectl get pods -n default
   ```
- **Screenshot:**  
![bonus app pod]()
---


---

## Final Cleanup

After testing, remove the deployed applications:
```bash
helm uninstall argo -n argocd
kubectl delete namespace argocd
kubectl delete -f ArgoCD/argocd-python-dev.yaml
kubectl delete -f ArgoCD/argocd-python-prod.yaml
kubectl delete -f ArgoCD/argocd-node-app.yaml
```

---


```

