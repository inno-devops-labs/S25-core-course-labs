# ArgoCD Multi-Environment Deployment

## Overview
This document describes the implementation of GitOps practices using ArgoCD for managing multiple environments (dev and prod) of our Python application. The setup demonstrates automated deployment, configuration management, and self-healing capabilities.

## Environment Setup

### Dev Environment
```bash
$ kubectl get pods -n dev
NAME                                        READY   STATUS    RESTARTS   AGE
python-app-dev-deployment-b7464c7f8-7qnx2   1/1     Running   0         4m31s
```

Development environment characteristics:
- Single replica for faster development cycles
- Lower resource limits
- Shared development namespace

### Prod Environment
```bash
$ kubectl get pods -n prod
NAME                                         READY   STATUS    RESTARTS   AGE
python-app-prod-deployment-b7464c7f8-7qnx2   1/1     Running   0         4m31s
python-app-prod-deployment-b7464c7f8-gjztb   1/1     Running   0         4m31s
python-app-prod-deployment-b7464c7f8-r2hx9   1/1     Running   0         11s
```

Production environment characteristics:
- Three replicas for high availability
- Higher resource limits
- Dedicated production namespace
- Automated scaling and healing

## Auto-Sync Test Results

### Manual Override Test
Testing ArgoCD's ability to maintain desired state when manual changes are made.

```bash
# Before patch
$ kubectl get deployment python-app-prod-deployment -n prod
NAME                         READY   UP-TO-DATE   AVAILABLE   AGE
python-app-prod-deployment   3/3     3            3           5m59s

# After patch
$ kubectl patch deployment python-app-prod-deployment -n prod --patch '{"spec":{"replicas": 2}}'
deployment.apps/python-app-prod-deployment patched

# After ArgoCD auto-sync
$ kubectl get deployment python-app-prod-deployment -n prod
NAME                         READY   UP-TO-DATE   AVAILABLE   AGE
python-app-prod-deployment   3/3     3            3           5m59s
```

Results:
- Manual change detected by ArgoCD
- Automatic reconciliation triggered
- Desired state (3 replicas) restored

### Pod Deletion Test
Testing Kubernetes and ArgoCD's self-healing capabilities.

```bash
# Delete pod
$ kubectl delete pod -n prod -l app=python-app-prod
pod "python-app-prod-deployment-b7464c7f8-j885r" deleted
pod "python-app-prod-deployment-b7464c7f8-x5c2j" deleted

# Check auto-healing
$ kubectl get pods -n prod
NAME                                         READY   STATUS    RESTARTS   AGE
python-app-prod-deployment-b7464c7f8-7qnx2   1/1     Running   0         4m31s
python-app-prod-deployment-b7464c7f8-gjztb   1/1     Running   0         4m31s
python-app-prod-deployment-b7464c7f8-r2hx9   1/1     Running   0         11s
```

Results:
- Pods automatically recreated by Kubernetes
- Desired replica count maintained
- Application remains available during pod replacement

## ArgoCD Configuration
Key configuration settings for automated management:

```yaml
syncPolicy:
  automated:
    prune: true    # Remove resources that are no longer defined
    selfHeal: true # Revert manual changes automatically
  syncOptions:
    - CreateNamespace=true # Automatically create namespaces
```

## Implementation Details

### GitOps Workflow
1. Configuration stored in Git repository
2. ArgoCD monitors repository for changes
3. Automatic synchronization of changes
4. Continuous verification of cluster state

### Environment Separation
- Separate namespaces for isolation
- Environment-specific configurations
- Independent scaling and resource limits
- Shared infrastructure components

### Monitoring and Management
- ArgoCD dashboard for deployment status
- Real-time sync status monitoring
- Automatic drift detection
- Self-healing capabilities

## Conclusion
The implementation demonstrates successful:
- Multi-environment deployment
- Automated configuration management
- Self-healing capabilities
- GitOps practices 