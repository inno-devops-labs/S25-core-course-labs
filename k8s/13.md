# Lab 13: ArgoCD for GitOps Deployment

## Name: Yehia Sobeh

## GitHub Repo: [S25-core-course-labs](https://github.com/YehiaSobeh/S25-core-course-labs)

## Branch: `lab13`

---

## Task 1: Deploy and Configure ArgoCD

### 1. Install ArgoCD via Helm
```bash
helm repo add argo https://argoproj.github.io/argo-helm
helm install argo argo/argo-cd --namespace argocd --create-namespace
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=90s
```

### 2. Install ArgoCD CLI
```bash
curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
chmod +x argocd
sudo mv argocd /usr/local/bin/
argocd version --client
```

### 3. Access ArgoCD UI
```bash
kubectl port-forward svc/argo-argocd-server -n argocd 8080:443 &
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode
argocd login localhost:8080 --insecure --username admin --password <ADMIN_PASSWORD>
```

### 4. Configure Python App Sync
#### File: `k8s/ArgoCD/argocd-python-app.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: python-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/YehiaSobeh/S25-core-course-labs.git
    targetRevision: lab13
    path: k8s/app-python
    helm:
      valueFiles:
        - values.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: default
  syncPolicy:
    automated: {}
```
#### Apply Configuration
```bash
kubectl apply -f k8s/ArgoCD/argocd-python-app.yaml
argocd app sync python-app
```
#### Verify Sync
```bash
argocd app get python-app
# Output: Synced & Healthy
```

### 5. Test Sync Workflow
- Updated `values.yaml` (e.g., `replicaCount: 3`).
- Pushed changes to `lab13` branch.
- Observed auto-sync:
```bash
watch argocd app get python-app
```

---

## Task 2: Multi-Environment Deployment

### 1. Create Namespaces
```bash
kubectl create namespace dev
kubectl create namespace prod
```

### 2. Define ArgoCD Applications
#### File: `k8s/ArgoCD/argocd-python-dev.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: python-dev
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/YehiaSobeh/S25-core-course-labs.git
    targetRevision: lab13
    path: k8s/app-python
    helm:
      valueFiles:
        - values-dev.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  syncPolicy:
    automated: {}
```
#### File: `k8s/ArgoCD/argocd-python-prod.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: python-prod
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/YehiaSobeh/S25-core-course-labs.git
    targetRevision: lab13
    path: k8s/app-python
    helm:
      valueFiles:
        - values-prod.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: prod
  syncPolicy:
    automated: {}
```
#### Apply Configurations
```bash
kubectl apply -f k8s/ArgoCD/argocd-python-dev.yaml
kubectl apply -f k8s/ArgoCD/argocd-python-prod.yaml
```

### 3. Test Auto-Sync
- Updated `values-prod.yaml` (`replicaCount: 3 âž” 4`).
- Pushed changes to Git.
- Observed auto-sync:
```bash
watch argocd app get python-prod
```

### 4. Self-Heal Testing
#### Test 1: Manual Override of Replica Count
```bash
kubectl patch deployment python-prod-python-app -n prod --patch '{"spec":{"replicas": 2}}'
# ArgoCD reverted to 4 replicas.
```
##### Output Before:
```bash
kubectl get pods -n prod
NAME                                      READY   STATUS    RESTARTS   AGE
python-prod-python-app-abc123            1/1     Running   0          1m
python-prod-python-app-def456            1/1     Running   0          1m
```
##### Output After:
```bash
kubectl get pods -n prod
NAME                                      READY   STATUS    RESTARTS   AGE
python-prod-python-app-abc123            1/1     Running   0          5m
python-prod-python-app-def456            1/1     Running   0          5m
python-prod-python-app-ghi789            1/1     Running   0          1m
```
#### Test 2: Delete a Pod
```bash
kubectl delete pod -n prod -l app=python-app
# Kubernetes recreated the pod.
```
##### Output Before Deletion:
```bash
kubectl get pods -n prod
NAME                                      READY   STATUS    RESTARTS   AGE
python-prod-python-app-abc123            1/1     Running   0          5m
```
##### Output After Deletion:
```bash
kubectl get pods -n prod
NAME                                      READY   STATUS    RESTARTS   AGE
python-prod-python-app-def456            1/1     Running   0          10s
```

---

## Screenshots

![](/k8s/screnshoots/lab13/1.png)
![](/k8s/screnshoots/lab13/2.png)
![](/k8s/screnshoots/lab13/3.png)

## Explanation of how ArgoCD handles configuration drift vs. runtime events.
```
ArgoCD Handling of Drift vs. Runtime Events
Configuration Drift:
ArgoCD continuously monitors the cluster and compares it to the desired state in Git. If a manual change (e.g., scaling replicas) deviates from Git, ArgoCD auto-reverts the drift during the next sync.

Runtime Events:
Transient issues (e.g., pod crashes, node failures) are handled by Kubernetes (self-healing). ArgoCD ignores these unless they violate the Git-defined state (e.g., replica count).

Key Difference:

Drift = State mismatch (Git vs. Cluster).

Runtime = Short-lived disruptions (Kubernetes fixes itself).
```

