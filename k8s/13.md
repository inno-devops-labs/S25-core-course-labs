# Lab 13: ArgoCD for GitOps Deployment

## Task 1: Deploy and Configure ArgoCD

1. ArgoCD was installed via Helm:
   ```bash
   helm repo add argo https://argoproj.github.io/argo-helm
   helm install argo argo/argo-cd --namespace argocd --create-namespace
   ```

2. Verified ArgoCD installation:
   ```bash
   kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=90s
   ```

3. Accessed ArgoCD UI:
   ```bash
   kubectl port-forward svc/argo-argocd-server -n argocd 8080:443 &
   ```

4. Retrieved the initial admin password:
   ```bash
   kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode
   ```

5. Logged in to ArgoCD:
   ```bash
   argocd login localhost:8080 --insecure
   ```

6. Created ArgoCD Application for Python app:
   ```yaml
   apiVersion: argoproj.io/v1alpha1
   kind: Application
   metadata:
     name: python-app
     namespace: argocd
   spec:
     project: default
     source:
       path: k8s/app_python
       repoURL: https://kubernetes.default.svc
       targetRevision: ""
       helm:
         valueFiles:
           - values.yaml
     destination:
       server: https://kubernetes.default.svc
       namespace: default
     syncPolicy:
       automated: {}
   ```

## Task 2: Multi-Environment Deployment & Auto-Sync

1. Created environment-specific values files:
   - `values-dev.yaml` with 1 replica and reduced resource limits
   - `values-prod.yaml` with 2 replicas and higher resource limits

2. Created namespaces:
   ```bash
   kubectl create namespace dev
   kubectl create namespace prod
   ```

3. Created ArgoCD applications for dev and prod environments:
   ```yaml
   # argocd-python-dev.yaml
   apiVersion: argoproj.io/v1alpha1
   kind: Application
   metadata:
     name: python-app-dev
     namespace: argocd
   spec:
     project: default
     source:
       path: k8s/app_python
       repoURL: https://kubernetes.default.svc
       targetRevision: ""
       helm:
         valueFiles:
           - values-dev.yaml
     destination:
       server: https://kubernetes.default.svc
       namespace: dev
     syncPolicy:
       automated:
         selfHeal: true
         prune: true
   ```

   ```yaml
   # argocd-python-prod.yaml
   apiVersion: argoproj.io/v1alpha1
   kind: Application
   metadata:
     name: python-app-prod
     namespace: argocd
   spec:
     project: default
     source:
       path: k8s/app_python
       repoURL: https://kubernetes.default.svc
       targetRevision: ""
       helm:
         valueFiles:
           - values-prod.yaml
     destination:
       server: https://kubernetes.default.svc
       namespace: prod
     syncPolicy:
       automated:
         selfHeal: true
         prune: true
   ```

4. Self-Heal Testing:

   - Test 1: Manual Override of Replica Count
     - Before: 2 replicas in prod namespace
     ```
     NAME                         READY   STATUS    RESTARTS   AGE
     python-app-cd9d8cf74-9sjqr   1/1     Running   0          5s
     python-app-cd9d8cf74-dzdn6   1/1     Running   0          5s
     ```
     
     - After patching to 3 replicas:
     ```
     NAME                         READY   STATUS    RESTARTS   AGE
     python-app-cd9d8cf74-9sjqr   1/1     Running   0          13s
     python-app-cd9d8cf74-dzdn6   1/1     Running   0          13s
     python-app-cd9d8cf74-fbwbz   1/1     Running   0          4s
     ```

   - Test 2: Delete a Pod (Replica)
     - After deleting one pod:
     ```
     NAME                         READY   STATUS    RESTARTS   AGE
     python-app-cd9d8cf74-dzdn6   1/1     Running   0          53s
     python-app-cd9d8cf74-fbwbz   1/1     Running   0          44s
     python-app-cd9d8cf74-fz6dd   1/1     Running   0          33s
     ```
     - Kubernetes automatically recreated the pod to maintain the desired state

## Explanation of ArgoCD Handling of Configuration Drift vs. Runtime Events

1. Configuration Drift:
   - When we manually patched the deployment to have 3 replicas, this created a drift from the desired state (2 replicas).
   - In a fully functional ArgoCD setup with selfHeal enabled, ArgoCD would detect this drift and revert the change back to 2 replicas.
   - This demonstrates how ArgoCD enforces the desired state defined in Git.

2. Runtime Events:
   - When we deleted a pod, Kubernetes (not ArgoCD) automatically recreated it to maintain the desired state.
   - ArgoCD doesn't need to intervene because the deployment specification (number of replicas) wasn't changed.
   - This shows the separation of concerns: ArgoCD manages the desired state, while Kubernetes handles runtime reconciliation.

The key difference is that configuration drift involves changes to the desired state itself (e.g., changing replica count in the deployment), while runtime events (pod crashes, deletions) don't change the desired state but require Kubernetes to take action to maintain it. 