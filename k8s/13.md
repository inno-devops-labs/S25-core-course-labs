# ArgoCD for GitOps Deployment

## Task 1: Deploy and Configure ArgoCD

### Install, configure, setup ArgoCD

First of all, I install **ArgoCD via Helm** and **ArgoCD CLI** according to the attached guide in `S25-core-course-labs
/lab13.md`

Next, I **access the ArgoCD UI** and **configure Python App Sync** also following the instructions from `S25-core-course-labs
/lab13.md`

### Check the application status:

```bash
egor@egor-100-HP:~/PycharmProjects/S25-core-course-labs/k8s$ argocd app get python-app
Name:               argocd/python-app
Project:            default
Server:             https://kubernetes.default.svc
Namespace:          default
URL:                https://argocd.example.com/applications/python-app
Repo:               https://github.com/zDragonLORD1010/S25-core-course-labs.git
Target:             lab13
Path:               k8s/app-python
Helm Values:        values.yaml
Sync Policy:        Automated (Prune, SelfHeal)
Sync Status:        Synced to lab13 (b26a34d)
Health Status:      Progressing

Pods:
GROUP  KIND                   NAMESPACE  NAME                                 STATUS  HEALTH       HOOK  MESSAGE
       ServiceAccount         default    python-app-app-python                Synced  Healthy            
       Secret                 default    python-app-app-python-secret         Synced  Healthy            
       ConfigMap              default    python-app-app-python-config         Synced  Healthy            
       PersistentVolumeClaim  default    python-app-app-python-pvc            Synced  Healthy            
       Service                default    python-app-app-python                Synced  Healthy            
apps   Deployment             default    python-app-app-python                Synced  Healthy            
batch  Job                    default    python-app-pre-install-hook          Synced  Succeeded     
```

### Results

I modified the `values.yaml` and **committed and pushed** the changes to the repository.

After all the changes, I got the following result:

![argo_app.jpg](Data%20for%20report/argo_app.jpg)

```bash
Name:               argocd/python-app
Project:            default
Server:             https://kubernetes.default.svc
Namespace:          default
URL:                https://argocd.example.com/applications/python-app
Repo:               https://github.com/zDragonLORD1010/S25-core-course-labs.git
Target:             lab13
Path:               k8s/moscow-time
Helm Values:        values.yaml
Sync Policy:        Automated (Prune, SelfHeal)
Sync Status:        Synced to lab13 (gh3486b)
Health Status:      Healthy  
```

## Task 2: Multi-Environment Deployment & Auto-Sync

### 1. Set Up Multi-Environment Configurations

I created environment-specific values files for the `app-python`:

- `values-dev.yaml` - `dev` configuration with 1 replica
- `values-prod.yaml` - `prod` configuration with 3 replicas

### 2. Create Namespaces

I created separate namespaces for each environment

```bash
egor@egor-100-HP:~/PycharmProjects/S25-core-course-labs/k8s$ kubectl create namespace dev
namespace/dev created
egor@egor-100-HP:~/PycharmProjects/S25-core-course-labs/k8s$ kubectl create namespace prod
namespace/prod created
```

### 3. Deploy Multi-Environment via ArgoCD (Enable auto-sync and self-healing)

Created two ArgoCD application manifests with auto-sync and self-healing:

- `argocd-python-dev.yaml` - for `dev` environment
- `argocd-python-prod.yaml` - for `prod` environment

![argo_app_dev.jpg](Data%20for%20report/argo_app_dev.jpg)

![argo_app_prod.jpg](Data%20for%20report/argo_app_prod.jpg)

### Testing

**Test 1: Manual Override of Replica Count**

Modified the deployment's replica count manually:

```bash
egor@egor-100-HP:~/PycharmProjects/S25-core-course-labs/k8s$ kubectl patch deployment python-app-prod-app-python -n prod --patch '{"spec":{"replicas": 2}}'
```

Output after waiting for self-healing:

```bash
NAME                                          READY   STATUS      RESTARTS   AGE
python-app-prod-app-python-912db54ac-kb517    1/1     Running     0          4m31s
python-app-prod-app-python-912db54ac-2b23s    1/1     Running     0          45s
python-app-prod-app-python-912db54ac-f7ln1    1/1     Running     0          4m31s
python-app-prod-pre-install-hook              0/1     Completed   0          5m12s
```

**Test 2: Delete a Pod (Replica)**

Deleted a pod in the prod namespace:

```bash
egor@egor-100-HP:~/PycharmProjects/S25-core-course-labs/k8s$ kubectl get pods -n prod -o name | grep -v pre-install | head -1 | xargs kubectl delete -n prod
```

Output after waiting for Kubernetes to recreate the pod:

```bash
NAME                                          READY   STATUS      RESTARTS   AGE
python-app-prod-app-python-912db54ac-bd538    1/1     Running     0          47s
python-app-prod-app-python-912db54ac-2b23s    1/1     Running     0          4m48s
python-app-prod-app-python-912db54ac-f7ln1    1/1     Running     0          8m34s
python-app-prod-pre-install-hook              0/1     Completed   0          9m15s
```

### Results

Confirmed ArgoCD:

```bash
argocd app diff python-app-prod
```
p.s no output (= no drift detected)

Both tests were identical in purpose, which means the result was the same.

![argo_argo.jpg](Data%20for%20report/argo_argo.jpg)

**Configuration Drift:**

ArgoCD identified the manual change from three to two replicas as a departure from the `values-prod.yaml` - specified target state. The synchronization policy had `selfHeal:true`, therefore ArgoCD immediately reversed the update to preserve the intended state.

**Runtime Events:**

Argo CD detected no deviations when we removed the module because the deployment specification was unaltered.  Rather, the Kubernetes controller's built-in reconciliation cycle automatically generated a new module when it recognized a discrepancy between the desired and actual number of modules.

This experiment shows how Kubernetes and ArgoCD work in tandem to keep the system stable:
- ArgoCD makes sure the settings correspond to those specified in Git.
- The status of the runtime environment is matched by the configurations that are used thanks to Kubernetes.
