# AgroCD

## Task 1

## Task 2

```bash
$ kubectl patch deployment python-app-prod-app-python -n prod --patch '{"spec":{"replicas": 5}}'
```

```bash
$ kubectl get pods -n prod
NAME                                          READY   STATUS    RESTARTS   AGE
python-app-prod-app-python-68d44d6f88-2schs   1/1     Running   0          17m
python-app-prod-app-python-68d44d6f88-gszzw   1/1     Running   0          17m
python-app-prod-app-python-68d44d6f88-l8dsb   1/1     Running   0          17m
```

```bash
$ kubectl get pods -n prod -w
NAME                                          READY   STATUS    RESTARTS   AGE
python-app-prod-app-python-68d44d6f88-gszzw   1/1     Running   0          25m
python-app-prod-app-python-68d44d6f88-l8dsb   1/1     Running   0          25m
python-app-prod-app-python-68d44d6f88-xvzql   1/1     Running   0          4m44s
python-app-prod-app-python-68d44d6f88-gszzw   1/1     Terminating   0          25m
python-app-prod-app-python-68d44d6f88-p4bch   0/1     Pending       0          0s
python-app-prod-app-python-68d44d6f88-p4bch   0/1     Pending       0          1s
python-app-prod-app-python-68d44d6f88-p4bch   0/1     ContainerCreating   0          1s
python-app-prod-app-python-68d44d6f88-p4bch   1/1     Running             0          32s
```

```bash
$ argocd app diff python-app-prod
//empty output
```

```bash
$  kubectl get pods -n prod
NAME                                          READY   STATUS    RESTARTS   AGE
python-app-prod-app-python-68d44d6f88-l8dsb   1/1     Running   0          27m
python-app-prod-app-python-68d44d6f88-p4bch   1/1     Running   0          2m1s
python-app-prod-app-python-68d44d6f88-xvzql   1/1     Running   0          7m16s
```

If I understood correctly `AgroCD` is constantly comparing the live state with the repo. I assume that sync policy is automated

**When a drift Occurs**

1. It marks the app as `OutOfSync`
2. Reverts manual changes
3. Prunes resources (e. g. If a resource has been deleted manually but is defined in Git, ArgoCD will restore it.)
4. Attempts to restore the state of the failing resources

**Runtime events**

Here it simply monitors the state, and if some pod is, for example, in a crash loop, all the repair process will be done by kubernetes handlers