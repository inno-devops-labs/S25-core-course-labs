# Lab 15: Kubernetes Monitoring and Init Containers

## Task 1: Kubernetes Cluster Monitoring with Prometheus

### Kube Prometheus Stack Components

The Kube Prometheus Stack is a comprehensive monitoring solution for Kubernetes that combines several powerful components:

1. **Prometheus Operator**
   - Manages Prometheus and Alertmanager deployments
   - Automatically generates monitoring configurations
   - Provides Custom Resource Definitions (CRDs) for monitoring setup

2. **Prometheus**
   - Core monitoring system that collects and stores metrics
   - Pulls metrics from configured targets at regular intervals
   - Provides a powerful query language (PromQL) for data analysis

3. **Alertmanager**
   - Handles alerts sent by Prometheus
   - Groups, deduplicates, and routes alerts to different receivers
   - Supports various notification channels (email, Slack, etc.)

4. **Grafana**
   - Visualization platform for metrics
   - Provides pre-built dashboards for Kubernetes monitoring
   - Allows creation of custom dashboards and alerts

5. **Node Exporter**
   - Collects hardware and OS metrics from nodes
   - Exposes metrics about CPU, memory, disk, and network usage
   - Runs as a DaemonSet on each node

6. **Kube State Metrics**
   - Generates metrics about Kubernetes objects
   - Provides information about deployments, pods, services, etc.
   - Helps monitor the state of Kubernetes resources

7. **Prometheus Adapter**
   - Enables custom metrics for Horizontal Pod Autoscaling
   - Converts Prometheus metrics to Kubernetes custom metrics API
   - Supports dynamic scaling based on application metrics

### Installation and Setup Results

After installing the Kube Prometheus Stack, here's an explanation of the deployed resources:

#### Pods (po)
- `monitoring-grafana`: The Grafana pod that provides the visualization interface
- `monitoring-kube-prometheus-operator`: The operator that manages Prometheus and Alertmanager instances
- `monitoring-kube-state-metrics`: Generates metrics about Kubernetes objects
- `monitoring-prometheus-node-exporter`: Collects hardware and OS metrics from nodes

#### Services (svc)
- `monitoring-grafana`: Exposes Grafana UI on port 80
- `monitoring-kube-prometheus-alertmanager`: Handles alert routing and notifications (ports 9093, 8080)
- `monitoring-kube-prometheus-operator`: The operator's API endpoint (port 443)
- `monitoring-kube-prometheus-prometheus`: The main Prometheus server (ports 9090, 8080)
- `monitoring-kube-state-metrics`: Exposes Kubernetes state metrics (port 8080)
- `monitoring-prometheus-node-exporter`: Exposes node metrics (port 9100)

#### ConfigMaps (cm)
The system creates multiple ConfigMaps that serve different purposes:
1. Dashboard configurations for Grafana
2. Prometheus scraping configurations
3. Alerting rules
4. Various monitoring configurations for different Kubernetes components:
   - Node monitoring
   - Cluster resources
   - Namespace resources
   - Workload resources
   - Core components (etcd, apiserver, etc.)

All services are running as ClusterIP type, which means they're only accessible within the cluster. To access Grafana or Alertmanager, we'll need to use port-forwarding or create appropriate ingress rules. 

### Accessing Grafana

To access Grafana:

1. Run the command: `minikube service monitoring-grafana -n monitoring`
2. Use the following credentials:
   - Username: `admin`
   - Password: `prom-operator`

### Monitoring Results

After accessing Grafana, we can find the following information in the dashboards:

1. CPU and Memory consumption of StatefulSet:
   - Navigate to "Kubernetes / Compute Resources / Workload"
   - Filter by StatefulSet workload type

2. Pods CPU Usage in default namespace:
   - Navigate to "Kubernetes / Compute Resources / Namespace (Workloads)"
   - Filter by "default" namespace
   - Look at the "CPU Usage" panel

3. Node Memory Usage:
   - Navigate to "Kubernetes / Compute Resources / Node (Pods)"
   - Check "Memory Usage" and "Memory Usage (MB)" panels

4. Kubelet-managed Pods and Containers:
   - Navigate to "Kubernetes / Kubelet"
   - Look for "Pod Count" and "Container Count" metrics

5. Network Usage of Pods:
   - Navigate to "Kubernetes / Networking / Pod"
   - Filter by "default" namespace

6. Active Alerts:
   - Navigate to "Alerting" section in Grafana
   - Or access Alertmanager directly: `minikube service monitoring-kube-prometheus-alertmanager -n monitoring`

[Note: The specific metrics will be populated once we have our application running and generating metrics] 

## Task 2: Init Containers Implementation

### Implementation Details

We have successfully implemented an Init Container that creates a file which is then used by the main container. Here's the breakdown of the implementation:

1. **Volume Creation**:
   - Created a shared `emptyDir` volume named `shared-volume`
   - This volume is shared between the init container and the main container

2. **Init Container**:
   - Uses the `busybox` image
   - Creates an HTML file with a simple greeting message
   - Mounts the shared volume at `/work-dir`
   - Executes a command to write content to `/work-dir/index.html`

3. **Main Container**:
   - Uses the `nginx` image
   - Mounts the shared volume at `/usr/share/nginx/html`
   - Serves the HTML file created by the init container

### Proof of Success

The implementation was verified by checking the contents of the created file:

```bash
$ kubectl exec pod/init-demo -- cat /usr/share/nginx/html/index.html
<h1>Hello from Init Container</h1>
```

This output confirms that:
1. The init container successfully created the file
2. The file was properly shared with the main container
3. The content is accessible in the expected location

The complete implementation can be found in the `init-container.yaml` file. 