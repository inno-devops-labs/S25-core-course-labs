# Lab 14: Kubernetes StatefulSet Report

## Current State of Resources

```bash
NAME                              READY   STATUS    RESTARTS   AGE
pod/lab14-stateful-python-app-0   1/1     Running   0          73s

NAME                                         READY   AGE
statefulset.apps/lab14-stateful-python-app   1/1     18m

NAME                                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
service/kubernetes                           ClusterIP   10.96.0.1       <none>        443/TCP    35m
service/lab14-stateful-python-app            ClusterIP   10.105.60.238   <none>        8000/TCP   18m
service/lab14-stateful-python-app-headless   ClusterIP   None            <none>        8000/TCP   18m

NAME                                                     STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-lab14-stateful-python-app-0   Bound    pvc-4dd05a94-9cd3-4525-9be4-2f3d5802abd0   1Gi        RWO            standard       18m
```

## Application Testing

### Visits Counter Behavior
- The application successfully maintains a visit counter in `/data/visits`
- Each pod maintains its own counter
- The counter persists across pod restarts
- Current visit count: 17

### Persistent Storage Validation
We tested persistence by:
1. Checking the current visit count (17)
2. Deleting the pod
3. Waiting for pod recreation
4. Verifying the visit count remained the same (17)

This confirms that:
- The PVC is properly bound
- Data persists across pod restarts
- The StatefulSet correctly reattaches the volume to the new pod

### Headless Service and DNS Resolution
The headless service allows direct pod-to-pod communication using DNS. We tested this with:

```bash
nslookup lab14-stateful-python-app-0.lab14-stateful-python-app-headless.default.svc.cluster.local
```

Result:
```
Name:   lab14-stateful-python-app-0.lab14-stateful-python-app-headless.default.svc.cluster.local
Address: 10.244.0.16
```

This shows that:
- DNS resolution works correctly
- Each pod has a stable network identity
- Pods can be addressed directly using their DNS names

## StatefulSet Characteristics

### Ordered Deployment
- Pods are created in order (0, 1, 2, etc.)
- Each pod has a stable network identity
- Each pod has its own persistent storage

### Parallel Operations
For our application, parallel operations are safe because:
- Each pod maintains its own independent counter
- There's no need for coordination between pods
- The application is stateless except for the visit counter
- Each pod's data is isolated in its own PVC

### Update Strategy
The StatefulSet uses the default `RollingUpdate` strategy, which is appropriate because:
- It ensures zero downtime during updates
- It maintains the order of pod updates
- It allows for controlled rollouts

## Health Probes
The application implements:
- Liveness probe: Ensures the application is running
- Readiness probe: Ensures the application is ready to serve traffic

These probes are critical for stateful applications because:
- They ensure data consistency
- They prevent serving traffic from unhealthy pods
- They help maintain application reliability

## Conclusion
The StatefulSet implementation successfully provides:
1. Stable network identities
2. Persistent storage
3. Ordered deployment
4. Zero-downtime updates
5. Health monitoring

The application demonstrates proper state management and persistence, making it suitable for production use in a Kubernetes environment. 