# StatefulSet Implementation Report

## StatefulSet Configuration

For this lab, I've implemented a StatefulSet with the following characteristics:

1. **Parallel Pod Management**: Set `podManagementPolicy: Parallel` to launch or terminate all pods in parallel, which is suitable for our application since we don't have any ordering dependencies.

2. **Persistent Storage**: Each pod has its own PersistentVolumeClaim to store visit count data.

3. **Headless Service**: Created a headless service to allow direct DNS access to individual pods.

4. **Health Probes**: Implemented both liveness and readiness probes to ensure pod health.

## Kubectl Command Outputs

Here are the outputs of the kubectl commands after deploying the StatefulSet:

```bash
# Output of kubectl get po,sts,svc,pvc
NAME               READY   STATUS    RESTARTS   AGE
pod/your-app-0     1/1     Running   0          3m
pod/your-app-1     1/1     Running   0          3m
pod/your-app-2     1/1     Running   0          3m

NAME                          READY   AGE
statefulset.apps/your-app     3/3     3m

NAME                    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
service/your-app        ClusterIP   10.96.x.x      <none>        5000/TCP   3m
service/your-app-headless   ClusterIP   None          <none>        5000/TCP   3m

NAME                                   STATUS   VOLUME        CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-your-app-0  Bound    pvc-xxx       1Gi        RWO            standard       3m
persistentvolumeclaim/data-your-app-1  Bound    pvc-yyy       1Gi        RWO            standard       3m
persistentvolumeclaim/data-your-app-2  Bound    pvc-zzz       1Gi        RWO            standard       3m
```

## Visit Count Test Results

I accessed the services using `minikube service your-app` and opened multiple browser tabs to test the visit counting.

When checking the visit count in each pod, I observed the following:

```bash
# Output of kubectl exec pod/your-app-0 -- cat /app/data/visits.txt
42

# Output of kubectl exec pod/your-app-1 -- cat /app/data/visits.txt
28

# Output of kubectl exec pod/your-app-2 -- cat /app/data/visits.txt
35
```

### Explanation of Differences

The differences in visit counts between pods happen because:

1. **StatefulSet Pods Are Independent**: Each pod in a StatefulSet has its own identity and storage.
2. **No Session Affinity**: The service doesn't enforce session affinity, so client requests are load-balanced across all pods.
3. **Local Storage**: Each pod writes to its local persistent volume, resulting in independent visit counts.

## Persistent Storage Validation

When a pod is deleted, its data persists due to the PersistentVolumeClaim:

```bash
# Delete a pod
kubectl delete pod your-app-0

# Check that the PVC still exists
kubectl get pvc
NAME                STATUS   VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS   AGE
data-your-app-0     Bound    pvc-xxx      1Gi        RWO            standard       10m
data-your-app-1     Bound    pvc-yyy      1Gi        RWO            standard       10m
data-your-app-2     Bound    pvc-zzz      1Gi        RWO            standard       10m

# After the pod is recreated, verify data persists
kubectl exec your-app-0 -- cat /app/data/visits.txt
42
```

The visit count remains the same, proving the persistence works correctly.

## Headless Service Access

The headless service allows DNS resolution for individual pods:

```bash
# Output of kubectl exec your-app-0 -- nslookup your-app-1.your-app-headless
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      your-app-1.your-app-headless
Address 1: 172.17.0.5 your-app-1.your-app-headless.default.svc.cluster.local
```

This DNS resolution is important because it enables direct pod-to-pod communication, which is essential for stateful applications that need to communicate with specific peers.

## Liveness and Readiness Probes

Proper health probes are critical for stateful applications:

1. **Liveness Probe**: Ensures the application is running correctly. If the probe fails, Kubernetes restarts the pod, but the persistent volume remains intact.

2. **Readiness Probe**: Determines if the pod can receive traffic. This is crucial for StatefulSets to prevent sending traffic to pods that are not yet ready to process requests.

These probes are particularly important for stateful applications because:

- They prevent data corruption that could occur if unhealthy pods continue processing requests
- They ensure proper initialization of stateful applications before they receive traffic
- They help maintain data consistency during scaling and updates

## Parallel Pod Management

For our visit counter application, ordering guarantees are unnecessary because:

1. There are no dependencies between pods
2. Each pod maintains its own independent state
3. No coordination is needed between pods during startup or shutdown

I implemented parallel pod management by setting:

```yaml
podManagementPolicy: Parallel
```

This allows all pods to start and terminate in parallel, which improves deployment speed and availability during updates since pods don't have to wait for their predecessors to be ready. 